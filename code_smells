Code Smells

Refactoring
"Refactoring is the process of changing a software system in such away that it does not alter the external behavior of the code yet improves its internal structure. It is a disciplined way to clean up code that minimizes the chances of introducing bugs. In essence when you refactor you are improving the design of the code after it has been written."

    Tip
    "Refactoring (noun): a change made to the internal structure of software to make it easier to understand and cheaper to modify changing its observable behavior."

    "Refactor (verb): to restructure software by applying a series of refactorings without changing its observable behavior."

"With refactoring you can take a bad design, chaos even, and rework it into well-designed code. Each step is simple, even simplistic. You move a field from one class to another, pull some code out of a method to make into its own small changes can radically improve the design. It is the exact reverse of the normal notion of software decay. With refactoring you find the balance of work changes. You find that design, rather than occurring all up front, occurs continuously during development. You learn from building the system how to improve the design that stays good as development continues."

"A poorly designed system is hard to change. Hard because it is hard to figure out where the changes are needed. If it is hard to figure out what to change, there is a strong chance that the programmer will make a mistake and introduce bugs. [...] The problem with copying and pasting code comes when you have to change it later. If you are writing a program that you don't expect to change, then cut and paste is fine. If the program is long lived and likely to change, then cut and paste is a menace. [...] Furthermore, as the rules grow in complexity it's going to be harder to figure out where to make the changes and harder to make them without making a mistake."

    Tip
    "When you find you have to add a feature to a program, and the program's code is not structured in a convenient way to add the feature, first refactor the program to make it easy to add the feature, then add the feature."

"[...] the purpose of refactoring is to make the software easier to understand and modify. You can make many changes in software that make the software easier to understand and modify. You can make many changes in software that make little or no change in the observable behavior. Only changes made to make the software easier to understand are refactorings. A good contrast is performance optimization. Like refactoring, performance optimization does not usually change the behavior of a component (other than its speed); it only alters the internal structure. However, the purpose is different. Performance optimization often makes code harder to understand, but you need to do it to get the performance you need. [...] refactoring does not change the observable behavior of the software. The software still carries out the same function that it did before. Any user, whether an end user or another programmer, cannot tell that things have changed."

The two hats
"When you use refactoring to develop software, you divide your time between two distinct activities: adding function and refactoring. When you add function , you shouldn't be changing existing code; you are just adding new capabilities. You can measure your progress by adding tests and getting the tests to work. When you refactor, you make a point of not adding function; you only restructure the code. You don't add any tests (unless you find a case you missed earlier); you only change tests when you absolutely need to in order to cope with a change in an interface."

Why refactor?
    Preserve code
    "Without refactoring, the design of the program will decay. As people change code - changes to realize short-term goals or changes made without a full comprehension of the design of the code - the code loses its structure. It becomes harder to see the design by reading the code. [...] The harder it is to see the design code, the harder it is to preserve it, and the more rapidly it decays. Regular refactoring helps code retain its shape."

        "Poorly designed code usually takes more code to do the same things, often because the code quite literally does the same thing in several places. Thus an important aspect of improving design is to eliminate duplicate code. The importance of this lies in future modifications to the code. Reducing the amount of code won't make the system run any faster, because the effect on the footprint of the programs rarely is significant. Reducing the amount of code does, however, make a big difference in modification of the code. The more code there is, the harder it is to modify correctly. There's more code to understand. [...] By eliminating duplicates, you ensure that the code says everything once and only once, which is the essence of good design."

    Readability
    "Refactoring helps you to make your code easier to understand. Refactoring helps you to make your code more readable. When refactoring you have code that works but is not ideally structured. A little time spent refactoring can make the code better communicate its purpose. Programming in this mode is all about saying exactly what you mean."

    "[...] a good design is essential for rapid software development. Indeed, the whole point of having a good design is to allow rapid development. Without a good design, you can progress quickly fir a while, but soon the poor design starts to slow you down. You spend time finding and fixing bugs instead of adding new function. Changes take longer as you try to understand the system and find the duplicate code. New features need more coding as you patch over a patch that patches a patch on the original code base. [...] Refactoring helps you develop software more rapidly, because it stops the design of the system from decaying. It can even improve a design."

When to refactor?
"[...] refactoring is not an activity you set aside time to do. Refactoring is something you do all the time in little burst. You don't decide to refactor, you refactor because you want to do something else, and refactoring helps you do that other thing."

    The Rule of Three
    "The first time you do something, you just do it. The second time you do something similar, you wince at the duplication, but you do the duplicate thing anyway. The third time you do something similar, you refactor."

    Add a function
    "The most common time to refactor is when [you] want to add a new feature to some software. Often the first reason to refactor here is to help [you] understand some code [you] need to modify. [...] Whenever [you] have to think to understand what the code is doing, [ask yourself] if [you] can refactor the code to make that understanding more immediately apparent. Then refactor it. [...] Refactoring is a quick and smooth process. Once [you've] refactored, adding the feature can go much more quickly and smoothly."

    Code Review
    "Code reviews help spread knowledge through a development team. Reviews help more experienced developers pass knowledge to less experienced people. They help more people understand more aspects of a large software system. They are also very important in writing clear code. [...] Reviews also give the opportunity for more people to suggest useful ideas."

    "Refactoring also helps the code review have more concrete results. Not only are there suggestions, but also many suggestions are implemented there and then. You end up with much more of a sense of accomplishment from the exercise."

Kent Beck
    Why refactoring works
    "Programs have two kinds of value: what they can do for you today and what they can do for you tomorrow. Most times when we are programming, we are focused on what we want the program to do today. Whether we are fixing a bug or adding a feature, we are making today's program more valuable by making it more capable."

    "I know enough to do today's work. I don't know enough to do tomorrow's. But if I only work for today, I won't be able to work tomorrow at all."

    "What is it that makes programs hard to work with? [...]:
        -Programs that are hard to read are hard to modify.
        -Programs that have duplicated logic are hard to modify.
        -Programs that require additional behavior that requires you to change running code are hard to modify.
        -Programs with complex conditional logic are hard to modify.
    So, we want programs that are easy to read, that have all logic specified in one and only one place, that do not allow changes to endanger existing behavior, and that allow conditional logic to be expressed as simply as possible."

    "Refactoring is the process of taking a running program and adding to its value, not by changing its behavior but by giving it more of these qualities that enable us to continue developing at speed."

    Indirection
    "Indirection is a two-edged sword, however. Every time you break one thing into two pieces, you have more things to manage. It also can make a program harder to read as an object delegates to an object delegating to an object. So you'd like to minimize indirection."

    "Indirection can pay for itself [...]:
        -To enable sharing of logic. For example, a submethod invoked in two different places or a method in a superclass shared by all subclasses.
        -To explain intention and implementation separately. Choosing the name of each class and the name of each method gives you an opportunity to explain what you intend. The internals of the class or method explain how the intention is realized. If the internals also are written in terms of intention in yet smaller pieces, you can write code that communicates most of the important information about its own structure.
        -To isolate change. I use an object in two different places. I want to change the behavior in one of the two cases. If I change the object, I risk changing both. So I first make a subclass and refer to it in the case that is changing. Now I can modify the subclass without risking an inadvertent change to the other case.
        -To encode conditional logic. Objects have a fabulous mechanism, polymorphic messages, to flexibility but clearly express conditional logic. By changing explicit conditionals to messages, you can often reduce duplication, add clarity, and increase flexibility all at the same time."

    Refactoring games
    "Maintaining the current behavior of the system, how can you make you system more valuable, either by increasing its quality or by reducing its cost? The most common variant of the game is to look at your program. Identify a place where it is missing one or more of the benefits of indirection. Put in that indirection without changing the existing behavior. [...] With refactoring, you are never in danger of being completely wrong. The program always behaves at the end as it did at the beginning. In addition, you have the opportunity to add valuable qualities to the code."

    "There is a second, rarer refactoring game. Identify indirection that isn't paying for itself and take it out. Often this takes the form of intermediate methods that used to serve a purpose but no longer do. Or it could be a component that you expected to be shared or polymorphic but turned out to be used in only one place. When you find a parasitic indirection, take it out. Again, you will have more valuable program, [...] because it costs less indirection to get the same amount from the qualities."

When not to refactor
"There are times when you should not refactor at all. The principle example is when you should rewrite from scratch instead. there are times when the existing code is such a mess that although you could refactor it, it would be easier to start from the beginning. This decision is not an easy one to make. [...] A clear sign of the need to rewrite is when the current code just does not work. You may discover this only by trying to test it and discovering that the code is so full of bugs that you cannot stabilize it. Remember, code has to work mostly correctly before you refactor."

    "A compromise route is to refactor a large piece of software into components with strong encapsulation. Then you can make a refactor-versus-rebuild decision for one component at a time. This is a promising approach, [...] With a key legacy system, this would certainly be an appealing direction to take."

    "The other time you should avoid refactoring is when you are close to a deadline. At that point the productivity gain from refactoring would appear after the deadline and this be too late. Ward Cunningham has a good way to think of this. He describes unfinished refactoring as going into debt. Most companies need some debt in order to function efficiently. However, with debt come interest payments, that is, the extra cost of maintenance and extension caused by overly complex code. You can bear some interest payments, but if the payments become too great, you will be overwhelmed. It is important to manage your debt, paying parts of it off by means of refactoring."

    Tip
    "Other than when you are very close to a deadline, however, you should not put off refactoring because you haven't got time. Experience with several projects has shown that a bout of refactoring results in increased productivity. Not having enough time usually is a sign that you need to do some refactoring."

Refactoring and Design
"Refactoring has a special role as a complement to design. [...] Many people consider design to be the key piece and programming just mechanics. [...] But software is very different from physical machines. [...] One argument is that refactoring can be an alternative to upfront design. In this scenario you don't do any design at all. You just code the first approach that comes into your head, get it working, and then refactor it into shape."

    "Although doing only refactoring does work, it is not the most efficient way to work. Even the extreme programmers do some design first. They will try out various ideas with CRC cards or the like until they have a plausible first solution. [...] The point is that refactoring changes the role of upfront design. If you don't refactor, there is a lot of pressure in getting that upfront design right. The sense is that any changes to the design later are going to be expensive. Thus you put more time and effort into the upfront design to avoid the need for such changes."

    "With refactoring the emphasis changes. You still do upfront design, but now you don't try to find the solution. Instead all you want is a reasonable solution. You know that as you bid the solution, as you understand more about the problem, you realize that the best solution is different from the one you originally came up with. With refactoring this is not a problem, for it no longer is expensive to make the changes. An important result of this change in emphasis is a greater movement toward simplicity of design."

    Against Flexibility
    "The problem with building a flexible solution is that flexibility cost. Flexible solutions are more complex than simple ones. The resulting software is more difficult to maintain in general, although it is easier to flex in the direction [you] have in mind. Even there, however, you have to understand how to flex the design. [...] Building flexibility in all these places makes the overall system a lot more complex and expensive to maintain. The big frustration, of course, is that all this flexibility is note needed. Some of it is, but it's impossible to predict which pieces those are. To gain flexibility, you are forced to put in a lot more flexibility than you actually need."

        "Refactoring can lead to simpler designs without sacrificing flexibility. This make the design process easier and less stressful. Once you have a broad sense of things that refactor easily,you don't even think of the flexible solutions. You have the confidence to refactor if the time comes. You build the simplest thing that can possibly work. AS for the flexible, complex design, most of the time you aren't going to need it."

Refactoring and Performance
"Refactoring certainly will make software go more slowly, but it also makes the software more amenable to performance tunning. The secret to fast software, in all but hard real-time contexts, is to write tunable software first and then to tune it for sufficient speed."

    Budgeting
    "In this situation, as you decompose the design you give each component a budget for resources - time and footprint. That component must not exceed its budget for resources - time and footprint. That component must not exceed its budget, although a mechanism for exchanging budgeted times is allowed. Such a mechanism focuses hard attention on hard performance times. It is essential for systems such as heart pacemakers, in which late data is always bad data. This technique is overkill for other kinds of systems, such as the corporate information systems [...]"

    Constant Attention
    "With this approach every programmer, all the time, does whatever he or she can to keep performance high. This is a common approach and has intuitive attraction, but it does not work very well. Changes that improve performance usually male the program harder to work with. This slows development. This would be a cost worth paying if the resulting software were quicker, but usually it is not. The performance improvements are spread all around the program, and each improvement is made with a narrow perspective of the program's behavior. The interesting thing about performance is that if you analyze most programs, you find that they waste most of their time in a small fraction of the code. If you optimize all the code equally, you end up with 90 percent of the optimizations wasted, because you are optimizing code that isn't run much. The time spent making the program fast, the time lost because of lack of clarity, is all wasted time."

    Well-factored manner
    "In this approach you build your program in a well-factored manner without paying attention to performance until you begin a performance optimization stage, usually fairly late in development. During the performance optimization stage, you follow a specific process to tune the program. You begin by running the program under a profiler that monitors the program that tells you where it is consuming time and space. This way you can find that small part of the program where the performance hot spots lie. Then you focus on those performance hot spots and use the same optimizations you would use if you were using the constant attention approach. But because you are focusing your attention on a hot spot, you are having much more effect for less work. [...] As in refactoring you make the changes in small steps. After each step you compile, test, and rerun the profiler. If you haven't improved performance, you back out the change. You continue the process of finding and removing hot spots until you get the performance that satisfies tour user."

        "Having a well-factored program helps with this style of optimization in two ways. First, it gives you time to spend on preforming tuning. Because you have well-factored code, you can add function more quickly. This gives you more time to focus on performance. Second, with a well-factored program you have finer granularity for your performance analysis. Your profiler leads you to smaller parts of the code, which are easier to tune. Because the code is clearer, you have better understanding of your options and of what kind of tuning will work."

Tests
"[...] the first step is always the same. I need to build a solid set of test for that section of code. The tests are essential because even though I follow refactorings structured to avoid most of the opportunities for introducing bugs, I'm still human and still make mistakes. Thus I need solid tests. [...] An important part of the tests is the way they report their results. They either say "OK," meaning that all the strings are identical to the reference string, or they print a list of failures: lines that turned out differently. The tests are thus self-checking. It is vital to make tests self-checking. If you don't, you end up spending time hand checking some numbers from the test against some numbers of a desk pad, and that slows you down."

    Tip
    "Before you start refactoring, check that you have a solid of tests. These tests must be self-checking."

    "Refactoring changes the programs in small steps. If you make a mistake, it is easy to find the bug."

    "Any fool can write code that a computer can understand. Good programmers write code that humans can understand."

Problems with refactoring
"When you learn a new technique that greatly improves your productivity, it is hard to see when it does not apply. Usually you learn it within a specific context, often just a single project. It is hard to see what causes the technique to be less effective, even harmful. [...] Refactoring is like that now. We know the benefits of refactoring. We know they can make a palpable difference to our work. But we haven't had broad enough experience to see where the limitations apply."

    Databases
    "One problem area for refactoring is databases. Most business applications are tightly coupled to the database schema that supports them. That's one reason that the database is difficult to change. Another reason is data migration. Even if you have carefully layered your system to minimize the dependencies between the database schema and the object model, changing the database schema forces you to migrate the data, which can be a long a nd fraught task."

    Changing interfaces
    "One of the important things about objects is that they allow you to change the implementation of a software module separately from changing the interface. You can safely change the internals of an object without anyone else's worrying about it, but the interface is important - change that and anything can happen."

        "There is no problem changing a method name if you have access to all the code that calls that method. Even if the method is public, as long as you can reach and change all the callers, you can rename the method. There is a problem only if the interface is being used by code that you cannot find and change. When this happens, [...] the interface becomes a published interface (a step beyond a public interface). Once you publish and interface, you can no longer safely change it and just edit the callers."

        "[...] if a refactoring changes a published interface, you have to retain both the old interface and the new one, at least until your users have had a chance to react to the change. [...] You can usually arrange things so that the old interface still works. Try to do this so that the old interface calls the new interface. [...] Don't copy the method body - that leads you down the path to damnation by way of duplicated code."

        "Using published interfaces is useful, but it comes with a cost. So don't publish interfaces unless you really need to. This may mean modifying your code ownership rules to allow people to change other people's code in order to support an interface change. Often it is a good idea to do this with pair programming."

        Tip
        "Don't publish interfaces prematurely. Modify your code ownership policies to smooth refactoring."

Code Smells

    Duplicate Code
    "If you see the same code structure in more than one place, you can be sure that your program will be better if you find a way to unify them."

        "The simplest duplicate code problem is when you have the same expression in two methods of the same class. Then you have to do is Extract Method and invoke the code from both places."

        "Another common duplication problem is when you have the same expression in two sibling subclasses. You can eliminate this duplication by using Extract Method in both classes then Pull Up Field."

        "If the core is similar but not the same, you need to use ExtractMethod to separate the similar bits from the different bits. You may then find you can use Form Template Method."

        "If the methods do the same thing with a different algorithm, you can choose the clearer of the two algorithms and use Substitute Algorithm."

        "If you have duplicate code in two unrelated classes, consider using Extract Class in one class and then use the new component in the other. Another possibility is that the method really belonfs in a third class that should be referred to by both of the original classes. You have to decide where the method makes sense and ensure it is there and nowhere else."

    Long method
    "[...] the longer a procedure is, the more difficult it is to understand. [...] the real key to making it easy to understand small methods is good naming. If you have a good name for a method you don't need to look at the body."

        "The net effect is that you should be much more aggressive about decomposing methods. A heuristic we follow is that whenever we feel the need to comment something, we write a method instead. Such a method contains the code that was commented but is named after the intention of the code rather than how it does it. [...] The key here is not method length but the semantic distance between what the method does and how it does it."

        "Ninety-nine percent of the time, all you have to do to shorten a method is Extract Method. Find parts of the method that seem to go nicely together and make a new method."

        "If you have a method with lots of parameters and temporary variables, these elements get in the way of extracting methods. [...] You can often use Replace Temp with Query to eliminate the temps. Long lists of parameters can be slimmed down with Introduce PArameter Object and Preserve Whole Object."

        "How do you identify the clumps of code to extract? A good technique is to look for comments. They often signal this kind of semantic distance. A block of code with a comment that tells you what it is doing can be replaced by a method whose name is based on the comment. Even a single line is worth extracting if it needs explanation. Conditionals and loops also give signs for extractions. Use Decompose Conditional to deal with conditional expressions. With loops, extract the loop and the code within the loop into its own method."

    Large class
    "When a class is trying to do too much, it often shows up as too many instance variables. When a class has too many instance variables, duplicate code cannot be far behind."

        "You can Extract Class to bundle a number of the variables, Choose variables to go together in the component that makes sense for each. [...] More generally, common prefixes or suffixes for some subset of the variables in a class suggest the opportunity for a component. If the component makes sense as a subclass, you'll find Extract Subclass often is easier."

        "[...] a class with too much code is prime breeding ground for duplicate code, chaos and death. The simplest solution is to eliminate redundancy in the class itself. If you have five hundred-line methods with lots of code in common, you may be able to turn them into five ten line methods with another ten two-line methods extracted from the original."

        "[...] the usual solution for a class with too much code is either to Extract Class or Extract Subclass. A useful trick is to determine how clients use the class and to use Extract Interface for each of these uses."

        "If your large class is a GUI class, you may need to move data and behavior to a separate domain object. This may require keeping some duplicate data in both places and keeping the data in sync. Duplicate Observed Data suggests how to do this. In this case, [...] you might follow this by removing the GUI class and replacing it with Swing components."

    Long parameter list
    "In our early programming days we were taught to pass in as parameters everything needed by a routine [...] Objects change this situation because if you don't have something you need, you can always ask another object to get it for you. Thus with objects you don't pass in everything the methods needs; instead you pass enough so that the method can get to everything it needs. A lot of what a method needs is available on the method's host class. In object-oriented programs parameter lists tend to be much smaller than in traditional programs."

        "Use Replace Parameter with Method when you can get the data in one parameter by making a request of an object you already know about. This object might be a field or it might be a field or it might be another parameter. Use Preserve Whole Object to take a bunch of data gleaned from an object and replace it with the object itself. If you have several data items with no logical object, use Introduce Parameter Object."

        "There is one important exception to making these changes. This is when you explicitly do not want to create a dependency from the called object to the larger object. In those cases unpacking data and sending it along as parameters is reasonable, but pay attention to the pain involved. If the parameter list is too long or changes too often, you need to rethink your dependency structure."

    Divergent change
     "Divergent change occurs when one class is commonly changed in different ways for different reasons. [...] you often discover this only after you've added a few databases or financial instruments. Any change to handle a variation should change a single class, and all the typing in the new class should express the variation. To clean this up you identify everything that changes for a particular cause and use Extract Class to put them together."

    Shotgun surgery
    "Shotgun surgery is similar to divergent change but is the opposite. You whiff this when every time you make a kind of change, you have to male a lot of little changes to a lot of different classes. When changes are all over the place, they are hard to find, and it's easy to miss an important change."

        "In this case you want to use Move Method and Move Field to put all the changes into a single class. If no current class looks like a good candidate, create one. Often you can use Inline Class to bring a whole bunch of behavior together. You get a small dose of divergent change, but you can easily deal with that."

        "Divergent change is one class that suffers many kinds of changes, and shotgun surgery is one change that alters many classes. Either way you want to arrange things so that, ideally, there is a one-to-one link between common changes and classes."

    Feature envy
    "The whole point of objects is that they are a technique to package data with the processes used on that data. A classic smell is a method that seems more interested in a class other than the one it actually is in. The most common focus of the envy is the data. We've lost count of the times we've seen a method that invokes half-a-dozen getting methods on another object to calculate some value."

        "[...] the method clearly wants to be elsewhere, so you use Move Method to get it there. Sometimes only part of the method suffers from envy; in that case use Extract Method on the jealous bit and Move Method to give it a dream home."

        "The heuristic we use is to determine which class has most of the data and put the method with that data. This step is often made easier if Extract Method is used to break the method into pieces that go into different places."

        "The fundamental rule of thumb is to put things together that change together. Data and the behavior that references that data usually change together, but there are exceptions. When the exceptions occur, we move the behavior easily, because they isolate the small amount of behavior that needs to be overridden, at the cost of further indirection."

    Data clumps
    "Bunches of data that hang around together really ought to be made into their own object. The first step is to look for where the clumps appear as fields."

        "Use Extract Class on the fields to turn the clumps into an object. Then turn your attention to method signatures using Introduce Parameter Object or Preserve Whole Object to slim them down. The immediate benefit is that you can shrink a lot of parameter lists and simplify method calling. [...] As long as you are replacing two or more fields with the new object, you'll come out ahead."

        "A good test is to consider deleting one of the data values: if you did this, would the others make any sense? If they don't, it's a sure sign that you have an object that's dying to be born. Reducing field lists and parameters lists will certainly remove a few bad smells, but once you have objects, you get the opportunity to make a nice perfume. You can now look for cases of feature envy, which will suggest behavior that can be moved into your new classes. Before long these classes will be productive members of society."

    Primitive obsession
    "Most programming environments have two kinds of data. Record types allow you to structure data into meaningful groups. Primitive types are your building blocks. Records always carry a certain amount of overhead. They may mean tables in a database, or they may be awkward to create when you want them for only one or two things."

        "One of the valuable things about objects is that they blur or even break the line between primitive and larger classes. You can easily write little classes that are indistinguishable from the built-in types of the language."

        "You can move out of the cave into the centrally heated world of objects by using Replace Data Value with Objects on individual data values. If the data value is a type code, use Replace Type Code with Class if the value does not affect behavior. If you have conditionals that depend on the type code, use Replace Type Code with Subclasses or Replace Type Code with State/Strategy."

        "If you have a group of fields that should go together, use Extract Class. If you see primitives in parameter lists, try a civilizing dose of Introduce Parameter Object. If you find yourself picking apart an array, use Replace Array with Object."

    Switch statements
    "One of the most obvious symptoms of object-oriented code is its comparative lack of switch (or case) statements. The problem with switch statements is essentially that of duplication. Often you find the same switch statement scattered about a program in different places. If you add a new clause to the switch, you have to find all these switch, statements and change them. The object-oriented notion of polymorphism gives you an elegant way to deal with this problem."

        "Most times you see a switch statement you should consider polymorphism. The issue is where the polymorphism should occur. Often the switch statement switches on a type code. You want the method or class that hosts the type code value. So use Extract Method to extract the switch statement and then Move Method to get it onto the class where the polymorphism is needed. At that point you have to decide whether to Replace Type Code with Subclasses or Replace Type Code with State/Strategy. When you have set up the inheritance structure, you can use Replace Conditional with Polymorphism."

        "If you only have a few cases that affect a single method, and you don't expect them to change, then polymorphism is overkill. In this case Replace Parameter with Explicit Methods is a good option. If one of your conditional cases is a null, try Introduce Null Object."

    Parallel inheritance hierarchies
    "Parallel inheritance hierarchies is really a special case of shotgun surgery. In this case, every time you make a subclass of one class, you also have to make a subclass of another. You can recognize this smell because the prefixes of the class names in one hierarchy are the same as the prefixes in another hierarchy."

        "The general strategy for eliminating the duplication is to make sure that instances of one hierarchy refer to instances of the other. If you use Move Method and Move Field, the hierarchy on the referring class disappears."

    Lazy class
    "Each class you create costs money to maintain and understand. A class that isn't doing enough to pay for itself should be eliminated. Often this might be a class that used to pay its way but has been downsized with refactoring- Or it might be a class that was added because of changes that were planned but not made. Either way, you let the class die with dignity. If you have subclasses that aren't doing enough, try to use Collapse Hierarchy. Nearly useless components should be subjected to Inline Class."

    Speculative generality
    "Brian Foote suggested this name for a smell to which we are very sensitive. You get it when people [...] want all sort of hooks and special cases to handle things that aren't required. The result often is harder to understand and maintain. If all this machinery were being use, it would be worth it. But if it isn't, it isn't. The machinery just gets in the way, so get rid of it."

        "If you have abstract classes that aren't doing much, use Collapse Hierarchy. Unnecessary delegation can be removed with Inline Class. Methods with unused parameters should be subject to Remove Parameter. Methods named with odd abstract names should be brought down to earth with Rename Method."

        "Speculative generality can be spotted when the only users of a method or class are test cases. If you find such a method or class, delete it and the test case that exercises it. If you have a method or class that is a helper for a test case that exercises legitimate functionality, you have to leave it in, of course."

    Temporary field
    "Sometimes you see an object in which an instance variable is set only in certain circumstances. Such code is difficult to understand, because you expect an object to need all of its variables. Trying to understand why a variable is there when it doesn't seem to be used can drive you nuts."

        "Use Extract Class to create a home for the poor orphan variables. Put all the code that concerns the variables into the component. You may also be able to eliminate conditional code by using Introduce Null Object to create an alternatice component for when the variables aren't valid."

        "A common case of temporary field occurs when a complicated algorithm needs several variables. Because the implementer didn't want to pass around a huge parameter list, he put them in fields. But the fields are valid only during the algorithm; in other contexts they are just pain confusing. In this case you can use Extract Class with these variables and the methods that require them
        "



    Extract Method

        Motivation
        "Extract Method is one of the most common refactorings [...] look at a method that is too long or look at code that needs a comment to understand its purpose. [...] turn that fragment of code into its own method. [...] prefer short, well-named methods for several reasons. First, it increases the chances that other methods can use a method when is finely grained. Second, it allows the higher-level methods to read more like a series of comments. Overriding also is easier when the methods are finely grained. [...] small methods really work only when you have good names, so you need to pay attention to naming. [...] The key is the semantic distance between the method name and the method body. If extracting improves clarity,do it, even if the name is longer than the code you have extracted."

        Mechanics
        "-Create a new method and name it after the intention of the method (name it by what it does, not by how it does it).
            ?If the code you want to extract is very simple, such as a single message or function call, you should extract it if the name of the new method will reveal the intention of the code in a better way. If you can't come up with a more meaningful name, don't extract the code.
        -Copy the extracted code from the source method into the new target method.
        -Scan the extracted code for references to any variables that tare local in scope to the source method. These are local variables and parameters to the method.
        -See whether any temporary variables are used only within this extracted code. If so, declare them in the target method as temporary variables.
        -Look to see whether any of these local-scope variables are modified by the extracted code. If one variable is modified, see whether you can treat the extracted code as a query and assign the result to the variable concerned. If this is awkward, or if there is more than one such variable, you can't extract the method as it stands. You may need to use Split Temporary Variable and try again. You can eliminate temporary variables with Replace Temp with Query.
        -Pass into the target method as parameters local-scope variables that are read from the extracted code.
        -Compile when you have dealt with all the locally-scoped variables.
        -Replace the extracted code in the source method with a call to the target method.
            ?If you have moved any temporary variables over to the target method, look to see whether they were declared outside of the extracted code. If so, you can now remove the declaration.
        -Compile and test."

    Pull Up Field
    "Two subclasses have the same field."

        Motivation
        "If subclasses are developed independently. or combined through refactoring, you often find that they duplicate features- In particular, certain fields can be duplicates. Such fields sometimes have similar names but not always. The only way to determine what is going on is to look at the fields and see how they are used by other methods. If they are being used in a similar way, you can generalize them. Doing this reduces duplication in two ways. It removes the duplicate data declaration and allows you to move from the subclasses to the superclass behavior that uses the field."

        Mechanics
        "-Inspect all uses of the candidate fields to ensure they are used in the same way.
        -If the fields do not have the same name, rename the fields so that they have the name you want to use for the superclass field.
        -Compile and test.
        -Create a new field in the superclass.
            ?rarr; If the fields are private, you will need to protect the superclass field so that the subclasses can refer to it.
        -Delete the subclass fields.
        -Compile and test.
        -Consider using Self Encapsulated Field on the new field."

    Form Template Method
     "You have two methods in subclasses that perform similar steps in the same order, yet the steps are different."

        Motivation
        "Inheritance is a powerful tool for eliminating duplicate behavior. Whenever we see two similar methods in a subclass, we want to bring them together in a superclass. But what if they are not exactly the same? What do we do then? We still need to eliminate all the duplication we can but keep the essential differences. A common case is two methods that seem to carry out broadly similar steps in the same sequence, but the steps are not the same. In this case we can move the sequence to the superclass and allow polymorphism to play its role in ensuring the different steps do their things differently. This kind of method is called a template method (Gang of Four)."

        Mechanics
        "-Decomposer the methods so that all the extracted methods are either identical or completely different.
        -Use Pull Up Method to pull the identical methods into the superclass.
        -For the different methods use Rename Method so the signatures for all the methods at each step are the same.
            ?rarr; This makes the original methods the same in that they all issue the same set of method calls, but the subclasses handle the calls differently.
        -Compile and test after each signature change.
        -Use Pull Up Method on one of the original methods. Define the signatures of the different methods as abstract methods on the superclass.
        -Compile and test.
        -Remove the other methods, compile and test after each removal."
