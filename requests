Request data
 "In Laravel 5 [...] the ability to add additional blocks, layers, or modules allows us to separate the life cycle of the request into individual isolated pieces. Laravel [...] allow[s] us to put all of our code to handle the request inside the controller [...] although [...] we are able to easily separate the request into various pieces." pecoraro (2015): 50

 	"Inside the controller, the command is instantiated using the Data Transfer Object (DTO) paradigm. Then, the command is sent to the command bus, where it is handled by a handler class, which has two methods: __construct() and handle(). Inside the handle, we fire or instantiate an event. The event is likewise handled in the samw way by an event handler method with two methods: __construct() and handle()." pecoraro (2015): 51

 	User stories
 	"The idea for the command component can easily derive from a user story or a task required by a user to achieve a goal. [...] User stories, deriving from the agile methodology, guarantee that the code written closely matches the business requirement. They often follow the pattern "As a... I want to... so that...". This defines the actor, the intent, and the benefit. It helps us plan how each task will be converted into code." pecoraro (2015): 51

 "Data, and its manipulation, is important to any web application. Most of them rely upon retrieving data, changing it, creating it, and storing it. Data doesn’t always have to be a long term thing. The data provided from an HTML form, or attached to a request is, by default, only available for the duration of the request. Before we can manipulate or store the data from the request, we will first need to retrieve it. Fortunately, Laravel has a long winded, complicated method of accessing request data." rees (2013): 125

 	Laravel's request lifecycle
 	"Every request coming into a Laravel application, whether generated by an HTTP request or a command-line interaction, is immediately converted into an Illuminate Request object, which then crosses many layers and ends up being parsed by the application itself. The application then generates an Illuminate Response object, which is sent back out across those layes and finally returned to the end user." stauffer (2016): 386

 		"Every Laravel application has some form of configuration set up at the web server level, in an .htaccess file or an Nginx configuration settings or something similar, that captures every web request regardless of URL and routes it to public/index.php in the Laravel application directory(app)." stauffer (2016): 386

 		Bootstrapping the Application
 		"index.php doesn't actually have much that code in it. It has three primary functions. First , it loads Composer's auto load and Laravel's compiled application cache, which lives at bootstrap/cache/compiled.php.This file is what's generated when you run php artisan optimize, and it preloads all of the most commonly used classes for faster loading. [...] Next, it kicks off Laravel's bootstrap, creating the application container and registering a few coreservices [...] Finally, it creates an instance of the kernel, creates a request representing the current user's web request, and passes the request to the kernel to handle. The kernel responds with an Illuminate Response object, which index.php then returns to the end user, and terminates the page request." stauffer (2016): 387

 			Composer and Laravel
 			"Laravel's core functionality is separated into a series of components under the Illuminate namespace, qhich are all pulled into each Laravel app using Composer. Laravel also pulls in quite a few packages from Symfony and several other community-developed packages. In this way, LAravel is just as much an opinionated collection of components as it is a framwork." stauffer (2016):387

 			Laravel's kernel
 			"The kernel is the core route of every Laravel application, responsible for taking in a user request, processing it throuh middleware and handling exceptions and passing it to the page router, and then returning the final response. There are actually two kernels, but only one is used for each page request. One of the routers hndles web requests (the HTTP kernel) and the other handles console, cron, and Artisan requests (the console kernel). Each has a handle() methid that's responsible for tacking in an Illuminate Request object and returning an Illuminate Response object. The kernel runs all the bootstraps that need to run before every request, including determining which enviroment the current request is running in (staging, local, production, etc.) and running all of the service providers. The HTTP kernel additionally defines the list of middleware that will wrap each request, including the core middleware responsible for sessions and CSRF protection." stauffer (2016): 387

 		Service providers
 		"While there's a bit of pricedural code in these bootstraps, almost allof Laravel's bootstrap codeis sepatared into something Laravel calls service providers. A service provider is a class that encapsulates logic that various parts of your application need to run in order to bootstrap their core functionality. [...] many components of your application have bootstrap code that need to run when the application initializes. Service providers are a tool for grouping that bootstrap code into related classes."

 			register() & boot()
 			"Service providers have two importatn methods: boot() and register(). There's also a $defer property that you might choose to use. [...] First, all of the service providers' register() methods are called. This is where we want to bind classes and aliases to the container. You don't want to do anything in register() that relies on the entire application being bootstrapped. If your service provider is only going to register bindings in the container (i.e., teach the container how to resolve a given class or interface), but not perform any other bootstrapping, you can "defer" its registrations, which means they won't run unless one of the bindings is explicity requested from the container. This can speed upyout application's average time to bootstrap. If you want to defer your service provider's registrations, first give it a protected $defer property and set it to tru, and then give it a provides() method that returns a list of bindings the provider provides." stauffer (2016): 388
			You can now do any other bootstrapping here, like binding event listeners or defining routes "


	Request object
	"The Illuminate Rquest class is a Laravel-specific extension of Symfony's HttpFoundation\Rquest object. [...] Each request object is intended to represent every relevant piece of information you could care to know about a user's HTTP request. [...] Symfony's Request object instead collects all of the information necessary to represent a single HTTP request into a singl object, and then tacks on ceonvenience methods to make it easy to getuseful information from it. The Illuminate Request object adds even more convenience methids to get information about the request it's representing." stauffer (2016):392

		Symfony Http Foundation
		"Symfony's HttpFoundation suite of classes powers almost every PHP framework in existence at this point; this is the most popular and powerful set of abstractions avaliable in PHP for representing HTTP requests, responses, headers, cookies, and more." stauffer (2016): 392


	Retrieval
	 "[...] to retrieve some GET data from our URL. This type of data is appended to the URL in the form of key/value pairs. It’s what you might expect to see stored within the PHP $_GET array. [...] The Input::all() method is used to return an associative array of both $_POST and $_GET data contained within the current request. [...] Our destination route won’t be matched unless the HTTP verb matches the method used to create the route." rees (2013): 126

		GET vs POST
		"the GET data is handled last, and the values are replaced. Now we know that GET data, takes a higher priority than POST data within the request data array. Be sure to remember this if you ever happen to use both." rees (2013): 128

		Input::get()
		"Retrieving the entire request data array could be useful in some circumstances, however, we might also want to retrieve a single piece of information by key. That’s what the Input::get() method is for. [...] if something can’t be found in Laravel, it likes to provide null instead of throwing an exception or interfering with our application’s execution. Instead, Laravel does something much more useful. It allows us to provide a default value as a fallback." rees (2013): 128-129

		Input::has()
		"[...] if we want to find out whether a piece of request data exists or not, we can use the Input::has() option." rees (2013): 129-130

		Input::only() vs Input::except()
		"[...] we pass the Input::only() method an array containing the keys of the request data values we wish to return as an associative array. Actually, the array is optional. We could also pass each key as additional parameters to the method [...] we pass the Input::only() method an array containing the keys of the request data values we wish to return as an associative array. Actually, the array is optional. We could also pass each key as additional parameters to the method [...] Laravel has returned the subset of the request data that matches the keys that we requested. The data has been returned as an associative array. Of course, the only() method has an opposite. The except() method. The except() method will return an associative array of data that excludes the keys we have provided." rees (2013): 130-131

		Old input
		 "Our POST and GET request data is only available for a single request. They are short-term values. Kind of like how information is stored in RAM within your computer. Unless we move our request data to a data store, we won’t be able to keep it for very long. However, we can tell Laravel to hold onto it for another request cycle." rees (2013): 132

		 "Just like the get() , only() and except() methods, the old() , flashOnly() and flashExcept() methods can accept either a list of keys as parameters, or an array. [...] The second option might be really useful if you want to limit your request data using an existing array as keys." rees (2013): 135-136

			Input::flash()
			"[...] returning a Redirect response creates a new request cycle, just like a browser refresh. [...] After the redirect, the response data set is an empty array. There is no response data. Using the Input::flash() method, we can tell Laravel to hold on to the request data for an additional request. rees (2013): 133

			Input::old()
			"The Input::old() method lets Laravel know that we want the entire array of data that we flashed from the previous request. [...] As with the Input::get() , we can also retrieve a single value from the array of old data. [...] By passing a string to the Input::old() method, we can specify a key to return a single value." rees (2013): 133-134

			Input::flashOnly() vs Input::flashExcept()
			"[...] we can flash only a subset of data. It works kind of like the only() and except() methods we used earlier. Only this time we refer to the data that is flashed, and not the data retrieved. [...] As with the only() method, the flashOnly() method has a direct opposite which works in a similar fashion to except() . It will save only the values that don’t match the keys we provide for the next request." rees (2013): 134-135

			withInput() method
			"If you chain the withInput() method onto the redirect, Laravel will flash all of the current request data to the next request for you. [...] you can also use flashOnly() and flashExcept() with the withInput() chain method. [...] By passing the result of the Input::only() method to the withInput() chained method, we can limit the request data to the set of keys identified within the Input::only() method. Similarly, we can pass the Input::except() method to the withInput() method to limit the request data to the inverse" rees (2013): 136-137

	Uploaded files
	 "We can also receive files that have been uploaded as part of a multipart encoded form." rees (2013): 138

		Input::file()
		"[...] his object has a bunch of methods that will let us interact with it. You should note that the methods of this object belong to the Symfony project, and some are even inherited from the PHP SplFileInfo class. That’s the beauty of open source, sharing is caring! Symfony and PHP’s naming conventions tend to be a little bit longer than Laravel’s, but they are just as effective." rees (2013): 140

			getFileName() 				get the temporary filename given to our upload in its temporary location.
		
			getClientOriginalName() 	find the actual name of the file from when it was uploaded.
			
			getClietnSize() 			get the size of the file inbytes.
		
			getMimeType() 				This is a convention used to identify files.
		
			guessExtension() 			will attempt to guess the file extension from it’s mime type.
		
			getRealPath() 				get the current location of our uploaded file.

		move() method
		"The move() method’s first parameter is the destination that the file will be moved to. Make sure that the user that executes your web-server has write access to the destination, or an exception will be thrown. [...] Fortunately, the move() method accepts an additional, optional parameter that will allow us to give the file a name of our own choosing. If we retrieve the file’s real name and pass it as the second parameter to the move() method, it should arrive in the destination with a more sensible name. [...] First we retrieve the actual filename with the getClientOriginalName() method. Then we pass the value as the second parameter to the move() method." rees (2013): 144-145

	Cookies
	 "They are a method of storing some data on the client side; in the browser. [...] You can store anything you like in the cookie." rees (2013): 145

		Setting and getting cookies
		"We can use the Cookie::make() method to create a new cookie. [...] The first parameter of the method is a key that can be used to identify our cookie. We will need to use this key to retrieve the value later. The second parameter is the value of our cookie. [...] The third and final parameter lets Laravel know how long to store the cookie for, in minutes." rees (2013): 146

			withCookie()
			"The withCookie() method can be used to attach a cookie to a response object. When the response is served, the cookie is created. The only parameter to the withCookie() method is the cookie we created." rees (2013): 147

			Cookie::get()
			"[...] the Cookie::get() method. The first and only parameter is the name of the cookie to retrieve. [...] As with Input::get() , the Cookie::get() method will accept a default value as the second parameter [...]" rees (2013): 147

			Cookie::has()
			"We can use the Cookie::has() method to check to see if a cookie is set. This method accepts the cookie’s name as the first parameter and returns a boolean result." rees (2013): 147

			Cookie::forever()
			"Perhaps you don’t want your cookies to expire though? Thanks to Laravel’s mind reading, we can use the Cookie::forever() method to create a cookie that will never expire. The first and second parameters of the method are the same: a key, and a cookie value." rees (2013): 147

			Cookie::forget()
			"If we want to delete a cookie, or rather... force it to expire, we can use the Cookie::forget() method. The only parameter to this method is the name of the cookie we wish to forget." rees (2013): 148

		Cookie security
		"Laravel signs our cookies with an authentication code and encrypts them so that our users can’t read the cookies or edit them. If a cookie is tampered with and the authentication code isn’t what Laravel expects, then it will be ignored by Laravel." rees (2013): 148
