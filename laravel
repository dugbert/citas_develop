Laravel

SOLID design principle
 "SOLID consists of the five design principles articulated by Robert “Uncle Bob” Martin.[...] SOLID stands for
	1)	Single Responsibility Principle
	2)	Open Closed Principle
	3)	Liskov Substitution Principle
	4)	Interface Segregation Principle
	5)	Dependency Inversion Principle" sinha (2017): 17-18

	Single responsibility principle (classes)
	 "The Single Responsibility Principle means a class should have one, and I mean only one, reason to change. Limiting class knowledge is important. The class’s scope should be narrowly focused. A class would do its job and not be affected at all by the change that takes place on its dependencies. Remember, if we can build a library of small classes with well-defined responsibilities, our code will be more decoupled and easy to test and run." sinha (2017): 18

	 "[...] the single responsibility principle. It states that a class should have a single responsibility. 1 A good practice to follow is to list the responsibility of the class in the comment doc-blocks. This way you can remind yourself and others the purpose of this class and try to keep the responsibility minimal. [...] Don’t take the single responsibility principle too far. The less change a class experiences, the less all these principles really matter. [...] Remember that using principles has trade-offs. If it is easier to maintain one larger class rather than five decoupled smaller classes, don’t fight the tide. Encapsulate what varies and leave the rest alone." dockins (2017): 9-10

	Open/closed principle (classes)
	 "The Open Closed Principle means a class is always open for extension but closed for modification. How is that? Nothing except that any changes to behavior should be made without modification of source codes. If you can do your job without touching the source code, then you are following the Open Closed Principle!" sinha (2017): 18

	 "[...] the Liskov substitution principle, which is tough considering PHP is a duck-typed language. It doesn’t have strict variable types. However, PHP does have type-hinting [...] Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program [...]" dockins (2017): 12

	Liskov substitution principle (classes)
	 "Derived classes must be substitutable for their based class. It means objects should be replaceable with instances of their subtypes without altering the correctness of program." sinha (2017): 18

	Interface segregation principle (interfaces)
	 "The Interface Segregation Principle is an echo of Singular Responsibilities. If it is broken, Singular Responsibility is broken. In a nutshell, it says that interface is granular and focused. No implementation of interface should be forced on methods that it does not use. Accordingly, break into small interfaces as you require them for your implementation. Plan it before and enjoy the decoupled easy-going ride." sinha (2017): 18

	Dependency inversion principle (highlevel-code)
	 "[...] the Dependency Inversion Principle states that high­level codes should not depend on low­level codes. Instead the high­level code depends on ‘Abstraction’ that acts as a middle-man between high­level and low­level. The second aspect is that abstraction does not depend upon details but details depend upon abstractions." sinha (2017): 18

	 "The DIP (dependency inversion principle) states that one should depend on abstractions instead of concretions." dockins (2017): 15

	 "In software engineering, there is a saying: low coupling, high cohesion. Coupling is the degree to which one class relies on another class. Cohesion is the degree to which elements inside a class belong together. [...] To mitigate cohesion and coupling issues, follow the practice that high-level classes should not depend on low-level classes and vice versa. Instead, depend on abstractions such as an interface, abstract class, etc." dockins (2017): 16

JSON
 "JSON stands for JavaScript Object Notation. It was named this way because JavaScript was the first language to take advantage of the format. Essentially, JSON is a human readable method of storing arrays and objects with values as strings. It is used primarily for data transfer, and is a lot less verbose than some of the other options such as XML. Commonly it is used when the front-end part of your application requires some data from the back-end without a page reload. This is normally achieved using JavaScript with an AJAX request." rees (2013): 7-8

	JSON Synthax
	"By default JSON is stored without any white space between its values which might make it a little more difficult to read.
	This is normally to save on bandwidth when transferring the data. Without all the extra whitespace, the JSON string will be much shorter and thus be less bytes to transfer.
	The good news is that JSON doesn’t care about whitespace or line breaks between its keys and values." rees (2013): 8

	Data transfer format
	"JSON doesn’t support commenting since it’s used for data transfer." rees (2013): 10

	"JSON is a data transfer format, and not a language. It has no concept of variables. This is why you don’t need the assignment within the JSON snippet.
	The method of representing an object literal is very similar. This is no coincidence! [...] JSON was originally invented for use with JavaScript.
	In both JSON and JavaScript, objects are contained within { two curly braces } and consist of key-value pairs of data." rees (2013): 9

		JavaScript vs JSON
		"In the JavaScript variant the keys didn’t require quotes because they represent variables, but we just heard that JSON doesn’t have variables. This is fine since we can use strings as keys, and that’s exactly what JSON does to work around this problem.
		You may also have noticed that I used single quotes around the JavaScript values. This is a trap! That behaviour is perfectly acceptable with JavaScript, but JSON strings must be contained within double quotes.
		In both JavaScript and JSON, key-value pairs must be separated with a colon ( : ), and sets of key-value pairs must be separated with a comma ( , ).
		JSON will support strings and numerical types." rees (2013): 9-10

		Value-type support
		"JSON will allow the following value types.
		Double
		Float
		String
		Boolean
		Array
		Object
		Null" rees (2013): 10

		"Numeric values are represented without quotes. [...]
		Booleans are represented by the words true and false , both without quotes much like PHP itself. [...] string values are contained within double quotes and not single quotes.
		The null value works in a similar way to PHP, and is represented by the word null without quotes.
		We have seen objects. Much like the main JSON object itself, they are wrapped with curly braces and can contain all sorts of value types.
		Arrays once again look very similar to their JavaScript counterpart." rees (2013): 10

Composer
 "Composer expects its configuration to live at the root of your package along with the filename composer.json ." rees (2013): 13

	Packages
	"The tool that you are building is called a package. Imagine a little box containing everything needed to run your application, and describe it." rees (2013): 13

	"The package name consists of two words separated by a forward slash ( / ). The part before the forward slash represents the owner of the package. [...] The second part of the name string is the package name. Keep it simple and descriptive." rees (2013): 14-15

Filters
 "Filters are certain sets of rules or actions that can be applied to a route. They can be performed before or after a route’s logic is executed, however, you will find before filters to be more useful. Using before filters we can alter the flow of the application if a certain set of rules or criteria are not met. It’s a great way of protecting our routes." rees (2013): 71

	Route::filter()
	"We use the Route::filter() method to create a new filter. The first parameter is a friendly name that we will later use to assign the filter to a route. [...]The second parameter to the route is a callback [...] The callback is a function that is called when the filter is executed. If it returns a response type object, [...] then that response will be returned and will be served instead of the result of the route logic. If no response is returned from the filter callback, then the routes logic will continue as normal." rees (2013): 72

	Before vs after filters
	"The index ‘before’ tells the framework that we want to run our ‘birthday’ filter before the routes logic is executed. [...] We can attach a filter using the ‘after’ option of a route array, this way the filter will be executed after your route logic." rees (2013): 74

	Multiple filters
	"The pipe | character can be used to separate a list of filters. They will be executed from left to right, and the first that returns a response will end the request, and that response will be delivered as the result. If you like, you can use an array instead to provide your multiple filters." rees (2013): 75

	Parameters
	"Laravel provides a different set of parameters to ‘before’ and ‘after’ filters. You will notice that both filters receive $route and $request variables." rees (2013): 77

		$route
		"[...] the first parameter, you will see that it is an instance of Illuminate\Routing\Route. [...] The ‘Route’class represents a route used by the routing layer. This instance represents the current route that is being executed." rees (2013): 77

		$request
		"[...] the next parameter is an instance of the current request object. The Illuminate\Http\Request instance represents the state of the request being sent to your web server. It contains information about the URL, and data passed with the request, along with a great wealth of additional information." rees (2013): 77

		$response
		"The after filter receives an additional parameter, an instance of response object that is returned from the route the filter is acting on. This instance is due to be served as the response of the current request." rees (2013): 77

		Syntax
		"We can accept as many parameters as we like. To provide multiple parameters we must first add a colon : between the filter name and its parameters. The parameters themselves must be separated by a comma , . [...] It’s worth noting that just like functions, filter parameters can be assigned default values, making them optional." rees (2013): 79

	Filter classes
	"[...] any Laravel feature that requires a Closure will also have an alternative. A PHP Class.[...] First we need to create a filter alias [...] However, this time we will pass a string instead of a closure as the second parameter. [...] The second parameter for the method is a string that identifies the filter class to use." rees (2013): 80-81

	Global filters
	"[...] inside /app/filters.php you will notice two strange looking filters. These are the global filters and are executed before, and after, every request to your application. [...] They work exactly like normal filters, except that they apply to all routes by default. This means there is no need to add them to the before and after array indexes of our routes." rees (2013): 81-82

	Default filters
	"In the app/filters.php there are some filters that have already been created for you." rees (2013): 82

	Pattern filters
	"The pattern filter will allow you to match a before filter to a number of routes by supplying a routing pattern with a wildcard." rees (2013): 83

Interfaces and method injection
 "Interfaces can save us by encapsulating the actual logic. We are safe. As we don’t want to hit the database directly from our Controller class, we keep a shield in between them, namely, Interfaces. It will act as a medium between Eloquent ORM and Controller. [...] An Interface defines the syntactical contract that all the derived classes should follow. Specifically, the interface defines the ‘what’ part of the syntactical contract and the derived classes will describe the ‘how’ part of the contract." sinha (2017): 33

	Multiple interfaces
	"You can use several interfaces between them; don’t worry about using them throughout your application. The more you use it, the better. Some people may object to the extra typing, but personally I think that using Interfaces would make your application more robust and agile. You can test them without hitting your domain logic from your web layer." sinha (2017): 34

	Abstract classes
	"Classes defined as abstract may not be instantiated and any class that contains at least one abstract method must also be abstract. Remember that abstract methods can not define the implementation." sinha (2017): 19

	Object interfaces
	"[...] object interfaces allow you to create code which specifies which methods a class must implement, without having to define how these methods are handled. Interfaces are defined with the interface keyword, in the same way as a standard class, but without any of the methods having their contents defined. All methods declared in an interface must be public; this is the nature of an interface." sinha (2017): 19

Routing
 "Routing is the concept of setting up a new URI [...] It’s a static method that accepts two things: a URI and an anonymous function or Closure. [...] Here 'Route' is a class that has a static method ‘get’ that returns a ‘view’ method which presents a web page." sinha (2017): 21

	Route declaration
	"Routes are defined in the app/routes.php file, [...] Routes are always declared using the Route class." rees (2013): 52

	Verb method
	"[...] all requests made by a web browser contain a verb. Most of the time, the verb will be GET, which is used to request a web page. A GET request gets sent every time you type a new web address into your web browser. [...] There is also POST, which is used to make a request and supply a little bit of data with it. These are normally the result of submitting a form, where data must be sent to the web server without displaying it in the URL." rees  (2013): 52

		First Parameter
		"[...] the first parameter to the get() (or any other verb) method [...] defines the URI that you wish the URL to match." rees  (2013): 53

		Second Paramenter
		"The final parameter is used in this instance to provide the application logic to handle the request." rees (2013): 53

	Parameters
	"Route parameters can be used to insert placeholders into your route definition. This will effectively create a pattern in which URI segments can be collected and passed to the application’s logic handler." rees (2013): 56

	Named routes
	"Laravel has provided the named routing ability [...] we can give our routes a nickname. [...] Using the as index of our route array we can assign a nickname to a route. Try to keep it short, yet descriptive. You see, Laravel has a number of methods that help you generate links to the resources served by your application, and many of these have the ability to support route names." rees (2013): 105-106

		route() helper
		"If we use the route() helper, and then decide to change our URL, we no longer need to modify all of the links. They will all be resolved by their nickname." rees (2013): 106

		Retrieve route's nickname
		"Also, if you want to retrieve the nickname of the current route, you can use the handy currentRouteName() method on the ‘Route’ class." rees (2013): 107

	Secure routes
	"You may want your routes to respond to secure HTTP URLs so that they can handle confidential data. HTTPS URLs are layered on top of the SSL or TLS protocol to allow for increased security when you need it. [...] [...] By adding the HTTPS index to our routing array, our route will now respond to requests made to the route using the HTTPS protocol." rees (2013): 107-108

	Route to controllers
	"Be sure to remember that all of these advanced features are available to Controllers as well as routed Closures. To route to a Controller, simply add the uses parameter to the routing array, along with a controller-action pair." rees (2013): 107

	Parameter constraints
	"[...] we chain an additional where() method onto the end of our route definition. The ‘where’ method accepts the placeholder name as the first parameter, and a regular expression as the second. [...] You can attach as many conditions to your route as you like."

	Route groups
	"[...] using the group() method on the ‘Route’ object. The first parameter is an array. It works just like the ones we have been using within our routing methods. It can accept filters, secure indexes, and many of the other routing filters. The second parameter should be a Closure. When you define additional routes within this Closure, the routes inherit the properties of the group." rees (2013): 109

	Route models
	"The Route::model() method will let Laravel know that any route parameters with the same name as the first parameter to the method will be an Eloquent model instance defined by the second parameter. [...] Laravel will look at the integer supplied as a parameter, and perform a lookup on the model by primary key. It will then pass the appropriate model instance as a parameter to the controller action." rees (2013): 369

	Route prefixing
	"If many of your routes share a common URL structure, you could use a route prefix to avoid a small amount of repetition. [...] Using the prefix array option of the route group, we can specify a prefix for all of the URIs defined within the group. [...] Use route prefixes to avoid repetition within your routes, and to group them by purpose for organisational or structural value." rees (2013): 110-111

	Domain routing
	"URI’s are not the only way to differentiate a route. The host can also change. [...] By attaching the ‘domain’ index to the route grouping array, we are able to provide a host name, that must match the current hostname for any of the routes inside to be executed. The host name can either be a subdomain, or a completely different subdomain. As long as the web server is configured to serve requests from each host to Laravel, then it will be able to match them. That’s not all there is to domain based routing. We can also capture portions of the host name to use as parameters." rees (2013): 111-112

		Placeholder
		"You can provide a placeholder for a domain parameter within the ‘domain’ index by using { curly braces } , just like our URI parameters. The value of the parameter will be passed before any parameters of the routes held within the group. [...] By using a combination of wildcard subdomains, and routing parameters, you could prefix the domain with the username of your application’s users." rees (2013): 113

Responses
 "Laravel has a number of Response objects that make returning a meaningful reply a whole lot easier." rees (2013): 60
	
	Response object
	"The response object is an instance of a class that can be handed back to Laravel as the result of a routed closure or a controller action to enable the framework to serve the right kind of response to the browser. [...] Response objects generally contain a body, a status code, HTTP headers, and other useful information. [...] The status code for a Redirect would be a 301 . Laravel uses this information to construct a sensible result that can be returned to the browser." rees (2013): 64

		Response::make() method
		"we use the Response::make() method to create a new response object. The first parameter is the content or body of the response and the second parameter is the HTTP status code that will be served with the response." rees (2013): 65

			HTTP headers
			"HTTP headers are a collection of key-value pairs of data which represent useful information to the web browser that is receiving the response. Normally they are used to indicate the format of the result or how long a piece of content should be cached for. However, we are able to define custom headers as we please. [...] The collection of HTTP headers can be accessed as the headers property of the response object." rees (2013): 65

				$varible->headers->set()
				"Using the set() method on this collection we can add our own header to the collection by providing a key as a first parameter and the associated value as the second. Once our header has been added we simply return the response object [...] The browser will receive the headers along with the response and can use this information however it wishes." rees (2013): 66

				Content-Type
				"The Content-Type is a common header key used by browsers to distinguish between the various formats of content that are sent to them." rees (2013): 66

			Symfony 2
			"Laravel has used some of the more robust components that belong to the Symfony 2 project. The Laravel response object actually inherits most of its content from the Response object belonging to the Symfony HTTPFoundation component." rees (2013): 66-67

	Response Shortcuts
	"Laravel is more than a friend. It loves you. It really does. Because of this, it has provided a number of response shortcuts to make your life easier." rees (2013): 68

		JSON reponses
		"Laravel provides a Response::json() method that will configure the response object with a number of details that are specific to JSON results." rees (2013): 68

		Download responses
		"Serving files directly requires certain headers to be set. [...] The Response::download() method received a path to a file which will be served when the response is returned. You can also provide optional second and third parameters to configure a custom HTTP status code and an array of headers." rees (2013): 69

	Views
	"A view is just a plain text template that can be returned to the browser, though it’s likely that your views will contain HTML. Views use the .php extension and are normally located within the app/views directory. This means that PHP code can also be parsed within your views." rees (2013): 60

		Templates
		"The files representing views can be called templates. This may help you distinguish between the View objects and the HTML templates." rees (2013): 60

		"Laravel’s Blade provides a way to build templates that can benefit from inheritance." rees (2013): 97
			
			'extends' blade function
			"First we have the ‘extends’ blade function [...] This tells Blade which layout we will be using to render our content. The name that we pass to the function should look like those that you pass to View::make() [...] Remember that a period ( . ) character represents a directory separator when dealing with views." rees (2013): 99

			'section' blade function
			"We can use the @section blade function to inject content into sections within the parent template. [...] Everything that is contained between ‘@section’ and ‘@stop’ will be injected into the parent template, where the ‘@yield(‘body’)’ is. [...] we could have as many child templates as we want inheriting from this parent template." rees (2013): 99

			'parent' blade function
			"we might wish to append to this content, rather than replace it. To do this we can use the @parent helper. [...] The ‘@parent’ helper tells Blade to replace the parent marker, with the default content found within the parent’s section."

		View::make() method
		"Using the View::make() method we can create a new instance of a View response object. The first parameter we hand to the make() method is the view template that we wish to use. [...] Laravel [...] will by default assume that your views are located in app/views and will look for a file with an appropriate view extension. [...] Laravel will serve the result of our Closure to the web browser." rees (2013): 61

			Second parameter
			"[...] the second parameter of the make() method accepts an array that is passed to the view template. [...] When the array is passed to the view, the array keys are ‘extracted’ into variables that have the array key as their name and the given value. [...] You can store multidimensional arrays as deep as you like in your view data array." rees (2013): 62

		Control structures
		"PHP has a number of control structures. If statements, while, for and foreach loops. [...] the PHP opening <? and closing ?> tags are gone. [...] We can also strip out the colons : and semi ; colons. [...] We have prefixed our control statement lines with an at @ symbol. In fact, all blade control structures and helper methods are prefixed with this symbol, so that the template compiler knows how to handle them." rees (2013): 93-94

			{{ }} method
			"Everything surrounded by {{ double curly brackets }} is transformed into an echo by Blade when the template is processed. This is a much cleaner syntax, and a whole lot easier to type. Since the Blade template directives are translated directly to PHP we can use any PHP code within these brackets, including methods." rees (2013): 92

			{{{ }}} method
			"If we were to use {{{ three curly brackets }}} instead of {{ two }} then our output will be escaped, the angular brackets will be converted to HTML entities, and the Javascript will show as text within the page." rees (2013): 92

			Unless condition
			"PHP doesn’t have an ‘unless’ condition. However, Blade has provided a helper to allow it. [...] Unless is the exact opposite of an if statement. An if statement checks if a condition equates to a true value, and then executes some logic. However, the unless statement will execute its logic only if the condition equates to false. You can think of it as a control structure for pessimists." rees (2013): 95-96

			@inlcude()
			"With PHP, you are able to include() a file into the current file, executing its contents. You could do that with views to break them apart into separate files for organisational purposes. Laravel helps us achieve this goal by providing the @include() Blade helper method to import one view into another, parsing its contents as a Blade template if required. [...] Include takes the name of the view as a parameter, in the same short format as the View::make() method." rees (2013): 96-97
	
	Redirects
	"In some circumstances you may wish to redirect the flow of your application to another route or logic portion. In such a circumstance the Redirect reponse object will be useful. [...] A Redirect is a special type of response object which redirects the flow of the application to another route. [...] This can be really useful when a condition of some kind has failed and you need to redirect the user to a more useful location." rees (2013): 63-64

		Status code
		"The status code for a Redirect would be a 301 . Laravel uses this information to construct a sensible result that can be returned to the browser." rees (2013): 64

Controllers
 "In MVC framework controller has a definite role. It primarily controls the flow between model and view. [...] A controller is a transporter. It transports application logic to the presentation layer. A good design principle always encourages you write your application logic in a separate hidden file. A controller will only execute those methods and return a view. It will never know what it carries." sinha (2017): 29

	No-data
	"Controller will never know from where the data comes. It will do its job and forget about it." sinha (2017): 33

	Actions
	"The Controller is a class used to house routing logic. Normally, the Controller will contain a number of public methods known as actions. You can think of actions as the direct alternative to the closures [...], they are very similar in both appearance and functionality." rees (2013): 84
	"In fact, the controller action can contain any code that the Closure can." rees (2013): 85	

	Naming a controller
	"[...] you can call the Controller whatever you like. As long as your controller extends either BaseController or Controller then Laravel will know what you are trying to do. However, suffixing a controllers name with Controller." rees (2013): 85

	Methods
	"The class methods of our Controller are what actually contain our logic. Once again you can name them however you like [...]. These methods must be public for Laravel to be able to route to them. You can add additional private methods to the class for abstraction, but they cannot be routed to." rees (2013): 85

	Controller routing
	"In order to link a URI to a Controller we must define a new route within the /app/routes.php file. We are using the same Route::get() method that we used when routing Closures. However, the second parameter is completely different. This time we have a string. The string consists of two sections that are separated by an at sign ( @ )." rees (2013): 86

	RESTful controllers
	"We know that we can define the HTTP request verb that we want to match using the routing methods. However, when routing to Controllers you might want to keep the defining of the request verb close to your application logic." rees (2013): 88

		REST
		"REST (Representational State Transfer) is a an architectural protocol through which we imagine our URLs as nouns and give them common verbs like GET, POST, PUT, or DELETE. Every URL is a representation of an imaginary resource." sinha (2017): 32

		Route::controller() method
		"This single method will route all of the actions represented by our RESTful controller. [...] using this method to route to your controllers provides a distinct advantage over the original routing method. With this method, you will only have to provide a single routing entry for the Controller, rather than routing to every action independently." rees (2013): 89

			First parameter
			"The first parameter is the base URL. Normally RESTful routing is used to represent an object, so in most circumstances the base URL will be the name of that object. You can think of it as some what of a prefix to the actions that we have created within our RESTful controller." rees (2013): 89

			Second parameter
			"The second parameter you will already be familiar with. It’s the controller that we intend to route to. Once again, Laravel will happily accept a namespaced controller as a routing target so feel free to organise your Controllers however suits your needs." rees (2013): 89

	Resorceful controller

URL generation
 "Your web application revolves around routes and URLs. After all, they are what direct your users to your pages. At the end of the day, serving pages is what any web application must do. [...] In order to construct hyper links we need to build URLs to our application." rees (2013): 114

	Current URL
	"Getting the current URL in Laravel is easy. Simply use the URL::current() helper. [...] the result of URL::current() strips off the extra request data [...] the URL::full() method also includes additional request data. [...] after [a] redirect, the URL::previous method gives the URL for the previous request, which [...] is the URL to the first route." rees (2013): 114-115-116

	Generating framework URLs
	"[...] generating URLs to specific URI’s. We can do this using the URL::to() method. [...] Laravel [builds] a URL to the route we requested. You should note that [this route] doesn’t exist, but we can link to it anyway. Make sure that you remember this when generating links to URIs. You can specify additional parameters to the URL::to() method in the form of an array. These parameters will be appended to the end of the route." rees (2013): 116

		HTTPS protocol
		"If you want your generated URLs to use the HTTPS protocol, then you have two options. The first option is to pass true as the third parameter to the URL::to() method [...] However, if you don’t want to provide parameters to your URL, you will have to pass an empty array, or null as the second parameter. Instead, it’s more effective to use the descriptive URL::secure() [...] you can pass an array of route parameters as the second method parameter to the URL::secure() method [...] " rees (2013): 117

		URL::route()
		"Laravel has taken our route nickname, and found the associated URI. If we were to change the URI, the output would also change. This is very useful for avoiding having to change a single URI for many views. Just like the URL::to() method, the URL::route() method can accept an array of parameters as the second method parameter. Not only that, but it will insert them in the correct order within the URI. [...] Laravel will fill in the blanks in the correct order, with the parameters we have provided." rees (2013): 118-119

		URL::action()
		"[...] the URL::action() method. The first parameter of this method is the Class and action combination that we wish to retrieve the URL for. The format for this parameter is identical to that which we use for routing to controllers. Laravel [identifies] the URL for the controller action pair that we [request], and [delivers] it as a response. Just as with the other methods, we can supply an array of parameters as a second parameter to the URL::action() method." rees (2013): 119-120

	Asset URLs
	"URLs to assets such as images, CSS files and JavaScript need to be handled a little differently. " rees (2013): 120-121

		URL asset()
		"Laravel [creates] an absolute asset path for us. If we want to use a secure HTTPS protocol to reference our assets, then we can pass true as a second parameter to the URL::asset() method. [...] Laravel also provides a much more descriptive method of generating secure asset URLs. Simply use the URL::secureAsset() method and pass the relative path to your asset." rees (2013): 121-122

	Generation Shortcuts
	"First we have the url() function. It accepts identical parameters to the URL::to() method [...] The secure_url() function accepts the same signature as the URL::secure() method. The first parameter is the route, and the second is an array of route parameters to be appended. The route() function is a shortcut to the URL::route() method, and be used for generating URLs to named routes. [...] The action() function can be used as a shortcut to the URL::action() method, and can be used to generate links to controller actions. [...] they can accept second and third parameters for route parameters and secure URL generation. [...] The shortcut to the URL::asset() method is the asset() function, and as with all the other shortcuts, it accepts identical function parameters. [...] the shortcut to URL::secureAsset() is the secure_asset() function." rees (2013): 122-123

Request data
 "Data, and its manipulation, is important to any web application. Most of them rely upon retrieving data, changing it, creating it, and storing it. Data doesn’t always have to be a long term thing. The data provided from an HTML form, or attached to a request is, by default, only available for the duration of the request. Before we can manipulate or store the data from the request, we will first need to retrieve it. Fortunately, Laravel has a long winded, complicated method of accessing request data." rees (2013): 125
	
	Retrieval
	 "[...] to retrieve some GET data from our URL. This type of data is appended to the URL in the form of key/value pairs. It’s what you might expect to see stored within the PHP $_GET array. [...] The Input::all() method is used to return an associative array of both $_POST and $_GET data contained within the current request. [...] Our destination route won’t be matched unless the HTTP verb matches the method used to create the route." rees (2013): 126

		GET vs POST
		"the GET data is handled last, and the values are replaced. Now we know that GET data, takes a higher priority than POST data within the request data array. Be sure to remember this if you ever happen to use both." rees (2013): 128

		Input::get()
		"Retrieving the entire request data array could be useful in some circumstances, however, we might also want to retrieve a single piece of information by key. That’s what the Input::get() method is for. [...] if something can’t be found in Laravel, it likes to provide null instead of throwing an exception or interfering with our application’s execution. Instead, Laravel does something much more useful. It allows us to provide a default value as a fallback." rees (2013): 128-129

		Input::has()
		"[...] if we want to find out whether a piece of request data exists or not, we can use the Input::has() option." rees (2013): 129-130

		Input::only() vs Input::except()
		"[...] we pass the Input::only() method an array containing the keys of the request data values we wish to return as an associative array. Actually, the array is optional. We could also pass each key as additional parameters to the method [...] we pass the Input::only() method an array containing the keys of the request data values we wish to return as an associative array. Actually, the array is optional. We could also pass each key as additional parameters to the method [...] Laravel has returned the subset of the request data that matches the keys that we requested. The data has been returned as an associative array. Of course, the only() method has an opposite. The except() method. The except() method will return an associative array of data that excludes the keys we have provided." rees (2013): 130-131

		Old input
		 "Our POST and GET request data is only available for a single request. They are short-term values. Kind of like how information is stored in RAM within your computer. Unless we move our request data to a data store, we won’t be able to keep it for very long. However, we can tell Laravel to hold onto it for another request cycle." rees (2013): 132

		 "Just like the get() , only() and except() methods, the old() , flashOnly() and flashExcept() methods can accept either a list of keys as parameters, or an array. [...] The second option might be really useful if you want to limit your request data using an existing array as keys." rees (2013): 135-136

			Input::flash()
			"[...] returning a Redirect response creates a new request cycle, just like a browser refresh. [...] After the redirect, the response data set is an empty array. There is no response data. Using the Input::flash() method, we can tell Laravel to hold on to the request data for an additional request. rees (2013): 133

			Input::old()
			"The Input::old() method lets Laravel know that we want the entire array of data that we flashed from the previous request. [...] As with the Input::get() , we can also retrieve a single value from the array of old data. [...] By passing a string to the Input::old() method, we can specify a key to return a single value." rees (2013): 133-134

			Input::flashOnly() vs Input::flashExcept()
			"[...] we can flash only a subset of data. It works kind of like the only() and except() methods we used earlier. Only this time we refer to the data that is flashed, and not the data retrieved. [...] As with the only() method, the flashOnly() method has a direct opposite which works in a similar fashion to except() . It will save only the values that don’t match the keys we provide for the next request." rees (2013): 134-135

			withInput() method
			"If you chain the withInput() method onto the redirect, Laravel will flash all of the current request data to the next request for you. [...] you can also use flashOnly() and flashExcept() with the withInput() chain method. [...] By passing the result of the Input::only() method to the withInput() chained method, we can limit the request data to the set of keys identified within the Input::only() method. Similarly, we can pass the Input::except() method to the withInput() method to limit the request data to the inverse" rees (2013): 136-137

	Uploaded files
	 "We can also receive files that have been uploaded as part of a multipart encoded form." rees (2013): 138

		Input::file()
		"[...] his object has a bunch of methods that will let us interact with it. You should note that the methods of this object belong to the Symfony project, and some are even inherited from the PHP SplFileInfo class. That’s the beauty of open source, sharing is caring! Symfony and PHP’s naming conventions tend to be a little bit longer than Laravel’s, but they are just as effective." rees (2013): 140

			getFileName() 				get the temporary filename given to our upload in its temporary location.
		
			getClientOriginalName() 	find the actual name of the file from when it was uploaded.
			
			getClietnSize() 			get the size of the file inbytes.
		
			getMimeType() 				This is a convention used to identify files.
		
			guessExtension() 			will attempt to guess the file extension from it’s mime type.
		
			getRealPath() 				get the current location of our uploaded file.

		move() method
		"The move() method’s first parameter is the destination that the file will be moved to. Make sure that the user that executes your web-server has write access to the destination, or an exception will be thrown. [...] Fortunately, the move() method accepts an additional, optional parameter that will allow us to give the file a name of our own choosing. If we retrieve the file’s real name and pass it as the second parameter to the move() method, it should arrive in the destination with a more sensible name. [...] First we retrieve the actual filename with the getClientOriginalName() method. Then we pass the value as the second parameter to the move() method." rees (2013): 144-145

	Cookies
	 "They are a method of storing some data on the client side; in the browser. [...] You can store anything you like in the cookie." rees (2013): 145

		Setting and getting cookies
		"We can use the Cookie::make() method to create a new cookie. [...] The first parameter of the method is a key that can be used to identify our cookie. We will need to use this key to retrieve the value later. The second parameter is the value of our cookie. [...] The third and final parameter lets Laravel know how long to store the cookie for, in minutes." rees (2013): 146

			withCookie()
			"The withCookie() method can be used to attach a cookie to a response object. When the response is served, the cookie is created. The only parameter to the withCookie() method is the cookie we created." rees (2013): 147

			Cookie::get()
			"[...] the Cookie::get() method. The first and only parameter is the name of the cookie to retrieve. [...] As with Input::get() , the Cookie::get() method will accept a default value as the second parameter [...]" rees (2013): 147

			Cookie::has()
			"We can use the Cookie::has() method to check to see if a cookie is set. This method accepts the cookie’s name as the first parameter and returns a boolean result." rees (2013): 147

			Cookie::forever()
			"Perhaps you don’t want your cookies to expire though? Thanks to Laravel’s mind reading, we can use the Cookie::forever() method to create a cookie that will never expire. The first and second parameters of the method are the same: a key, and a cookie value." rees (2013): 147

			Cookie::forget()
			"If we want to delete a cookie, or rather... force it to expire, we can use the Cookie::forget() method. The only parameter to this method is the name of the cookie we wish to forget." rees (2013): 148

		Cookie security
		"Laravel signs our cookies with an authentication code and encrypts them so that our users can’t read the cookies or edit them. If a cookie is tampered with and the authentication code isn’t what Laravel expects, then it will be ignored by Laravel." rees (2013): 148

Forms
	
	Opening and closing
	 "To create our opening form tag, we use the Form::open() generator method. This method accepts only a single parameter, with many parameters. [...] We also use the Form::close() method to close the form, although I see no reason why you would need to do this. I suppose it looks neater next to the other source generator methods? It’s up to you whether you choose to use it, or </form> instead." rees (2013): 151

		Default form
		"Laravel knows that POST forms are the most popular choice when building web applications. For that reason it will use the POST method by default, overriding the default GET method that HTML assumes. [...] The accept-charset attribute is another useful attribute that Laravel provides for us. It will ensure that ‘UTF-8‘ will be used for character encoding when submitting the form. It’s a sensible default for most situations." rees (2013): 152

		_method
		"By providing a hidden input called ‘_method’ we can supply a value to represent our non HTML5 compatible HTTP verbs. Laravel’s routing will look at this POST request, see the included ‘_method’ data and route to the appropriate action." rees (2013): 153

		files
		"Remember how we learned how to upload files and retrieve information about them [...] By providing a new index named files with a boolean value of true , Laravel will add the necessary attribute to allow the uploading of files." rees (2013): 154

		Names and controllers
		"Instead of using the url index, we use the route index and provide the name of the route as a value. [...] To target our form at a controller action, instead of the url and route indexes, we use the action index and the controller-action pair as its value." rees (2013): 155

	Form fields

			Field labels
			"Labels can be generated using the Form::label() method. [...] The first parameter of the Form::label() method matches the name attribute of the field that they are describing. The second value, is the text of the label. [...] We should use labels whenever we can to describe our fields. [...] It’s worth noting that we can include other attribute and value pairs within our generated label element by providing a third parameter to the label() method. The third parameter is an array of attribute and value pairs." rees (2013): 156

			Text fields
			"Text fields can be used to collect string data values.[...] The first parameter for the Form::text() method is the name attribute for the element. This is what we will use to identify the field’s value within our request data collection. The second parameter is an optional one. It is a default value for the input element. [...] ust like the Form::label() method, our Form::text() method can accept an optional third parameter to supply an array of HTML attribute and value pairs." rees (2013): 157

			Textarea fields
			"The textarea field functions in a similar way to the text input type, except that they allow multiline data. [...] The first parameter is the name attribute for the element, and the second parameter once again is the default value. [...] Laravel has provided some default values, such as the amount of columns and rows for the field. We could easily override these values by adding new values for them to the optional final parameter." rees (2013): 158

			Password fields
			"[...] if we want our users to be able to type their innermost secrets into our application securely, then we need to make sure that their characters don’t display on screen. The ‘password’ input type is perfect for this. [...] The first parameter for the Form::password() method is the name attribute. As always, there is a final optional parameter for an array of additional element attributes." rees (2013): 159

			Checkboxes
			"Checkboxes allow for your form to capture boolean values. [...] The first parameter to the Form::checkbox() method is the field name attribute, and the second parameter is the field value . The third, optional value is whether or not the checkbox will be checked by default. The default is for the checkbox to be unchecked." rees (2013): 159-160

			Radio buttons
			"Radio buttons have an identical method signature to that of checkboxes. The difference is that you can use a number of radio input types to provide a method of selection within a small group of values." rees (2013): 160

			Select boxes
			"Select boxes, or drop-downs, are another way of providing a choice of values to the user of your application. [...] The Form::select() method accepts a name attribute as the first parameter, and an array of key-value pairs as a second parameter. The key for the selected option will be returned within the request data. The third, optional, parameter is the key for a value that will appear as selected by default." rees (2013): 161-162

				By category
				"If we want to, we can organise our select box options by category. To enable this option, all we need to do is provide a multidimensional array as the second parameter. The first level of the array will be the category, and the second level will be the list of values just as before." rees (2013): 162

			Email field
			"The email field type has the same method signature as the Form::text() method. The difference is that the Form::email() method creates a new HTML5 input element that will validate the value provided client side to ensure that a valid email address will be provided. [...] The first parameter to the Form::email() method is the name attribute for our input type. The second parameter is a default value . As always, and I hope you haven’t forgotten, there’s always a last, optional, array of additional element attributes." rees (2013): 164

			File upload field
			"The first parameter for the Form::file() method is the name attribute of the file upload element, however, in order for the upload to work, we need to ensure that the form is opened with the files option to include the multipart encoding type." rees (2013): 165

			Hidden fields
			"We can use hidden fields to supply extra data along with our forms. [...] The first parameter to the Form::hidden() method is the name attribute, [...] The second parameter is of course the value ." rees (2013): 165

	Form buttons

			Submit button
			"The first parameter to the Form::submit() is the value , which in the case of a button is the label used to identify the button. As with all of the input generation methods, the button generation methods will accept an optional last parameter to provide additional attributes." rees (2013): 166

			Normal buttons
			"When we need a button that won’t be used to submit our form, we can use the Form::button() method. [...] The parameters for the Form::button() method are exactly the same as the Form::submit() method." rees (2013): 167

			Image buttons
			"Instead of a native button, you could use the HTML5 image button type to submit your form. [...] The first parameter to the Form::image() method is the URL to an image to use for the button. [...] The second parameter is the value of the button." rees (2013): 167

			Reset buttons
			"The reset button can be used to clear the contents of your form. It’s used by your application’s users when they have made a mistake. [...] The first parameter to the Form::reset() method is the label that you would like to appear on the button." rees (2013):168

	Form macros
	 "Laravel comes equipped with a method that will allow you to define your own form generators [...] To define a macro we use the Form::macro() method. The first parameter is the name that will be used by the method that generates our form field. I’d suggest making it camelCase for this very reason. The second parameter to the method is a Closure. The value returned from this closure must be the source code required to construct our field. [...] The name of the method matches up to the nickname that we gave to our form macro." rees (2013): 168-169

		Placeholders
		"By providing placeholders within our macro closure, we can use their values within our rendered source." rees (2013): 170

	Form security
	 "What we need is a way of making sure that the data that is sent to us belongs to our own website. Not a problem. Laravel can handle this for us. You should probably know that this form of attack is known as ‘Cross Site Request Forgery’ or CSRF for short." rees (2013): 170

	 "To summarise, unless you want external applications and users to be able to post data to your forms, you should use the ‘CSRF’ filter to protect the routes which handle your form data." rees (2013): 172

		_token
		"It’s been created using the ‘secret’ value from our application config. If we tell Laravel to check for this value within our input data, then we can ensure that the data has been provided by a form that belongs to our application. [...] Laravel has included the csrf filter. [...] By attaching the csrf filter as a before filter to the route that will handle our form data, we can ensure that the _token field is present and correct. If our token is not present, or has been tampered with, then a Illuminate\Session\TokenMismatchException will be thrown, and our route logic will not be executed. [...] If you used Form::open() to create the wrapping form markup, then the security token will be included by default. However, if you want to add the token to manually written forms, then you must simply add the token generator method. [...] The Form::token() method will insert the hidden token field into our form." rees (2013): 171

Validation
	
	Simple validation
	 "A set of validation rules takes the form of an associative array. The array key represents the field that is being validated. The array value will consist of one or many rules that will be used to validate.[...] To perform validation within Laravel, we first need to create an instance of the Validation object." rees (2013): 177

		Validator::make()
		"We can use the Validator::make() method to create a new instance of our validator. The firstparameter to the make() method is an array of data that will be validated. The second parameter to the method is the set of rules that will be used to validate the data." rees (2013): 178

		passes() vs fails()
		"To test the result of the validation we can use the passes() method on the validator instance. This method will return a boolean response to show whether or not the validation has passed. A true response indicates that the data conforms to all of the validation rules. A false indicates that the data does not meet the validation requirements. [...] The fails() method returns the boolean opposite to the passes() method." rees (2013): 179-180

		min validation rule
		"The min validation rule ensures that the value is greater than or equal to the parameter provided. The parameter is provided after the colon : . This validation rule is a little special. It will react differently depending on the data that has been provided. For example, on a string value, our parameter ‘3’ will ensure that the value is at least 3 characters long. On a numerical value, it will ensure that the value is mathematically greater than or equal to our parameter. Finally, on uploaded files, the min validation rule will ensure that the uploaded file’s size in bytes is greater than or equal to the provided parameter." rees (2013): 181

		Multiple validation constrains
		"[...] we are able to pass a number of validation constraints within the value portion of our rules array by separating them with pipe | characters. [...] there’s an alternative way to provide multiple validation rules. [...] If you like, you can use a multidimensional array to specify additional validation rules." rees (2013): 182

	Validation rules

		accepted
		"This rule can be used to ensure that a positive confirmation has been provided. It will pass if the
		value under validation is one of the following values: ‘yes’, ‘on’ or a numeric 1. Its intended purpose
		is for when you wish to ensure that the user has agreed to something, for example, a terms and
		conditions checkbox." rees (2013): 184

		active_url
		"The ‘active_url’ validation will check to make sure that the value is a valid URL. To do this, it uses PHP’s own checkdnsrr() method, which not only checks the structure of the URL but also confirms that the URL is available within your DNS records." rees (2013): 184

		after
		"The ‘after’ validation rule accepts a single parameter, a string representation of a time. The rule will ensure that the field contains a date that occurs after the given parameter. Laravel will use the strtotime() PHP method to convert both the value and the rule’s parameter to a timestamp for comparison." rees (2013): 184

		alpha
		"The ‘alpha’ validation rule ensures that the provided value consists entirely of alphabetical
		characters." rees (2013): 184

		alpha_dash
		"The ‘alpha_dash’ rule will ensure that the provided value consists of alphabetical characters and also dashes - and/or underscores _ . This validation rule is very useful for validating URL portions such as ‘slugs’." rees (2013): 185

		alpha_num
		"The ‘alpha_num’ rule will ensure that the provided value consists of alphabetical and numeric characters. I like to use this rule to validate username fields." rees (2013): 185

		before
		"The ‘before’ rule accepts a single parameter. The value under question must occur before the parameter when both values are converted to timestamps using PHP’s strtotime() method. It is the exact opposite of the ‘after’ rule." rees (2013): 185

		between
		"The ‘between’ rule accepts two parameters. The value that is being validated must have a size that exists between these two parameters. The type of comparison depends on the type of data being compared. For example, on numerical fields the comparison will be a mathematical one. On a string, the comparison will be based upon the length of the string in characters. On a file, the comparison will be based upon the size of the file in bytes." rees (2013): 185

		confirmed
		"The ‘confirmed’ validation rule can be used to ensure that another field exists that matches the current name of the current field appended with _confirmation . The value being validated must match the value of this other field. One use for this rule is for password field confirmations to ensure that the user has not inserted a typographical error into either of the fields. The following example will ensure that ‘field’ matches the value of ‘field_confirmation’." rees (2013): 186

		date
		"The ‘date’ validation rule will ensure that our value is a valid date. It will be confirmed by running the value through PHP’s own strtotime() method." rees (2013): 186

		date_format
		"The ‘date_format’ validation rule will ensure that our value is a date string that matches the format provided as a parameter. To learn how to construct a date format string, take a look at the PHP documentation for the date() method." rees (2013): 186

		different
		"The ‘different’ validation rule will ensure that the value being validated is different to the value contained in the field described by the rule parameter." rees (2013): 186

		email
		"The ‘email’ validation rule will ensure that the value being validated is a valid email address. This rule is very useful when constructing registration forms." rees (2013): 187

		exists
		"The ‘exists’ validation rule will ensure that the value is present within a database table identified by the rule parameter. The column that will be searched will be of the same name as the field being validated. Alternatively, you can provide an optional second parameter to specify a column name. This rule can be very useful for registration forms to check whether a username has already been taken by another user. [...] Any additional pairs of parameters passed to the rule will be added to the query as additional where clauses." rees (2013): 187

		images
		"The ‘image’ validation rule will ensure that the file that has been uploaded is a valid image. For example, the extension of the file must be one of the following: .bmp , .gif , .jpeg or .png ." rees (2013): 187

		in
		"The ‘in’ validation rule will ensure that the value of the field matches one of the provided parameters." rees (2013): 188

		integer
		"This is an easy one! The ‘integer’ validation rule will ensure that the value of the field is an integer." rees (2013): 188

		ip
		"The ‘ip’ validation rule will check to make sure that the value of the field contains a well formatted IP address." rees (2013): 188

		max
		"The ‘max’ validation rule is the exact opposite of the ‘min’ rule. It will ensure that the size of the field being validated is less than or equal to the supplied parameter. If the field is a string, the parameter will refer to the length of the string in characters. For numerical values, the comparison will be made mathematically. For file upload fields the comparison will be made upon the size of the file in bytes." rees (2013): 188

		mimes
		"This rule will check the mime type of an uploaded file to ensure that it matches one of the parameters provided." rees (2013): 189

		min
		"The ‘min’ validation rule is the direct opposite of the ‘max’ rule. It can be used to ensure that a field value is greater than or equal to the provided parameter. If the field is a string, the parameter will refer to the length of the string in characters. For numerical values, the comparison will be made mathematically. For file upload fields the comparison will be made upon the size of the file in bytes." rees (2013): 189

		not_in
		"As the name suggests, this validation rule is the exact opposite of the ‘in’ rule. It will ensure that the field’s value does not exist within the list of supplied parameters." rees (2013): 189

		numeric
		"The ‘numeric’ rule will check to make sure that the field being validated contains a numeric value." rees (2013): 189

		regex
		"The ‘regex’ validation rule is the most flexible rule available within Laravel’s validation component. With this rule you can provide a custom regular expression as a parameter that the field under validation must match. [...] You should note that because pipe | characters can be used within regular expressions, you should use nested arrays rather than pipes to attach multiple validation rules when using the ‘regex’ rule." rees (2013): 190

		required
		"The ‘required’ validation rule can be used to ensure that the current field exists within the validation data array." rees (2013): 190

		required_if
		"The ‘required_if’ validation rule ensures that the current field must be present only if a field defined by the first parameter of the rule matches the value supplied by the second parameter." rees (2013): 190

		required_with
		"The ‘required_with’ is used to ensure that the current value is present only if one or more fields defined by the rule parameters are also present." rees (2013): 190

		required_without
		"The ‘required_without’ rule is the direct opposite to the ‘required_with’ rule. It can be used to ensure that the current field is present only when the fields defined by the rule parameters are not present." rees (2013): 191

		same
		"The ‘same’ validation rule is the direct opposite of the ‘different’ rule. It is used to ensure that the value of the current field is the same as another field defined by the rule parameter." rees (2013): 191

		size
		"The ‘size’ rule can be used to ensure that the value of the field is of a given size provided by the rule parameter. If the field is a string, the parameter will refer to the length of the string in characters. For numerical values, the comparison will be made mathematically. For file upload fields the comparison will be made upon the size of the file in bytes." rees (2013): 191

		unique
		"The ‘unique’ rule ensures that the value of the current field is not already present within the database table defined by the rule parameter. By default, the rule will use the name of the field as the table column in which to look for the value, however, you can provide an alternate column within the second rule parameter. This rule is useful for checking whether a users provide username is unique when handling registration forms. [...] You can provide extra optional parameters to list a number of IDs for rows that will be ignored by the unique rule." rees (2013): 191-192

		url
		"The ‘url’ validation rule can be used to ensure that the field contains a valid URL. Unlike the ‘active_- url’ validation rule, the ‘url’ rule only checks the format of the string and does not check DNS records." rees (2013): 192

	Error messages

		messages()
		"we can access the validation error messages object using the messages() method of our validator instance." rees (2013): 193

		$errors
		"When our view is loaded the $errors variable is added to the view data. It’s always there, and it’s always an error messages container instance, so you don’t have to worry about checking for its existence or contents. If we have used withErrors() to flash our error messages to the session in a previous request then Laravel will automatically add them to the errors object. We can access an array of all error messages by using the all() method on the $errors error messages instance." rees (2013): 196

		get()
		"We can use the get() method on the validation errors object to retrieve an array of errors for a single field. Simply pass the name of the field as the first parameter to the get() method." rees (2013): 198

		first()
		"By using the first() method on the validation errors object and passing the field name as a parameter, we can retrieve the first error message for that field." rees(2013): 199

		has()
		"By default the validation messages instance’s methods return an empty array or null if no messages exist. This means that you can use it without having to check for the existence of messages. However, if for some reason you wish to check whether or not an error message exists for a field, you can use the has() method." rees (2013): 199

		No-empty HTML elements
		"We can avoid having empty HTML elements appearing in our view source code by passing the containing HTML in string format as the second parameter to the all() and first() methods." rees (2013): 199

	Custom validation rules
	 "To create a custom validation rule we use the Validator::extend() method. The first parameter to the method is the nickname that will be given to the validation rule. This is what we will use to attach it to a field. The second parameter to the method is a closure. Should the closure return a boolean result of true then the validation attempt will have passed. If a boolean false is returned from the closure then the validation attempt will have failed." rees (2013): 203

		Parameters
		"The parameters that are handed to the closure are as follows. The first parameter is a string containing the name of the field that is being validated. [...] The second parameter to the extend closure contains the value of the field. The third parameter contains an array of any parameters that have been passed to the validation rule. Use them to customise your validation rules as required." rees (2013): 203

	Custom validation messages

		$messages
		"The messages array is an optional third parameter to the Validator::make() method. It contains any custom validation messages that you wish to provide and will also override the default validation messages. The key for the validation message array represents the name of the validation rule, and the value is the message to display if the validation rule fails. [...] We can also use this method to provide validation errors for our custom validation rule. Our custom rules won’t have validation error messages by default, so it’s normally a good idea to do so. [...] If we want to provide a custom error message for a specific field, we can do so by providing the name of the field, a period . character, and the type of validation as the key within the array." rees (2013): 206

Databases

	Abstraction layer
	"Laravel provides an abstraction layer, it decouples the framework’s database components from the RAW SQL, providing different queries for different types of databases. Simply put, you don’t have to worry about the SQL syntax, let Laravel take care of it. [...] Another advantage of using Laravel’s database abstraction layer is security. In most situations, unless I indicate otherwise, you won’t have to worry about escaping the values that you send to the database from Laravel. Laravel will escape these values for you, in an effort to prevent various forms of injection attacks." rees (2013): 209

	Configuration
	 "All of Laravel’s database configuration is contained in the file located at app/config/database.php. [...] When rows are returned from a query that one of Laravel’s database components executes, they will be default be in the form of a PHP stdClass object. [...] However, if you wish to alter the format in which rows are returned you may simply change the fetch option of the database configuration to something more suitable." rees (2013): 209-210

		Individual connection array

			driver
			"The driver option can be used to specify the type of database that we intend to connect to. [...]
			Here are the possible values.
				mysql - MySQL
				sqlite - SQLite
				pgsql - PostgreSQL
				sqlsrv - SQL Server" rees (2013): 213

			host
			"[...] can be used to specify the network location of the machine that hosts the database server. [...] You can provide either an IP address ( 168.122.122.5 ) or a host name ( database.example.com )." rees (2013): 213

			database
			"It is a string value used to identify the name of the database which the connection is due to act upon. In the case of an SQLite database, it is used to specify the file that is used to store the database [...]" rees (2013): 213

			username & password
			"The username and password indexes can be used to provide access credentials for your database connection." rees (2013): 214

			charset
			"[...] can be used to specify the default character set for a database connection." rees (2013): 214

			collation
			"You can set the default database collation using the collation index." rees (2013): 214

			prefix
			"[...] can be used to add a common prefix to your database tables." rees (2013): 214

Schema builder
 "Within the database our data can have structure, consist of different types, and have relationships. [...] In order to store our structured data, we first need to define the structure. [...]" rees (2013): 216
	
	Creating tables
	"To create a table we must make use of the create() method of the Schema class. [...] The Schema::create() method accepts two parameters. The first is the name of the table that we wish to create. [...] If the table we are creating will be used to store data representing a type of object, we should name the table in lowercase as the plural of the object. Database columns and tables are commonly named using snake-casing, where spaces are replaced with underscores ( _ ) and all characters are lowercase. [...] The second parameter to the method is a Closure, with a single parameter [...] [that] can be used to build the table structure." rees (2013): 216-217

		Column types

			increments
			"The increments() method is available on our $table instance to create a new auto incremental column. An auto incremental column will automatically be populated with an integer value that increments as each row is added. It will start at one. This column will also be the primary key for the table. The first parameter to the increments method is the name of the column that will be created." rees (2013): 217

			"The increments method will add an auto incremental integer primary key to the table. This is a very useful method for building the structure for Eloquent ORM models [...] The first and only parameter for the increments() method is the name of the column to create." rees (2013): 218-219

			bigIncrements
			"the bigIncrements() method will create a big integer, rather than a regular one. [...] the bigIncrements() method will accept a single string parameter as the column name." daylñe (2013): 219

			string
			"The string() method can be used to create varchar columns, which are useful for storing short string values. [...] The first parameter to string() method is the name of the column to create, however, there is an optional second parameter to define the length of the string in characters. The default value is 255." rees (2013): 219-220

			text
			"The text() method can be used to store large amounts of text that will not fit into a varchar column type. For example, this column type could be used to contain the body text of a blog post. [...] The text() method accepts a single parameter. The name of the column that will be created." rees (2013): 220

			integer
			"The integer column type can be used to store integer values [...] integer values are useful when referencing the auto incremented id of another table. We can use this method to create relationships between tables. [...] The first parameter to the integer() method is the name of the column. The second parameter is a boolean value that can be used to define whether or not the column should be auto incremental. The third parameter is used to define whether or not the integer is unsigned. A signed integer can be positive or negative, however, if you define an integer as unsigned, then it can only be postive. Signed integers can contain a range of integers from –2,147,483,648 to 2,147,483,647, where an unsigned integer can hold value from 0 to 4,294,967,295." rees (2013): 220-221

				"The method signature for all of the integer variants is exactly the same as the integer() method [...]" rees (2013): 221 

				bigInteger
				"Big integer values work exactly like normal integers, only they have a much larger range. A signed inter has a range of –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807, and unsigned integers have a range of 0 to 18,446,744,073,709,551,615." rees (2013): 221

				mediumInteger
				"The signed range is –8388608 to 8388607. The unsigned range is 0 to 16777215." rees (2013): 222

				tinyInteger
				"The signed range is –128 to 127. The unsigned range is 0 to 255." rees (2013): 222

				smallInteger
				"The signed range is –32768 to 32767. The unsigned range is 0 to 65535." rees (2013): 223
			
			float
			"Float column types are used to store floating point numbers. [...] The first value parameter is the name used to identify the column. The optional second and third integer parameters can be used to specify the length of the value, and the number of decimal places to use to represent the value. The defaults for these parameters are 8 and 2 respectively." rees (2013): 223-224

			decimal
			"The decimal() method is used to store [...] decimal values! It looks very similar to the float() method. [...] The method accepts a column name as the first parameter, and two optional parameters to represent the length and number of decimal places that should be used to define the column. The defaults for the optional parameters are again, 8 and 2." rees (2013): 224

			boolean
			"Not all values consist of large ranges of digits and characters. Some only have two states, true or false , 1 or 0 . Boolean column types can be used to represent these values. [...] The only parameter for the boolean method is the name given to the column it creates. [...] Tiny integers are used to represent boolean values as 1 or 0 ." rees (2013): 225

			enum
			"The enumerated type will store strings that are contained within a list of allowed values. [...] The first parameter is the name of the column that will be created. The second parameter is an array of values that are permitted for this enumerated type." rees (2013): 225

			date
			"[...] the date() method can be used to create columns that store dates. [...] The first and only parameter is used to specify the name of the column that will be created." rees (2013): 226

			dateTime
			"The dateTime() method will not only store a date, but also the time. [...] Once again, the name of the column to be created is the only parameter." rees (2013): 226-227

			time
			"Don’t want the date included with your times? Fine! Just use the time() method instead. [...] the first and only parameter to the time() method is the name of the column being created" rees (2013): 227

			timestamp
			"The timestamp() method can be used to store a date and time in the TIMESTAMP format. [...] The first and only value is the name of the database column that will be created." rees (2013): 227-228

			binary
			"The binary() method can be used to create columns that will store binary data. These types of columns can be useful for storing binary files such as images. [...] The only parameter to the binary method is the name of the column that is being created." rees (2013): 228

		Special column types

			timestamps()
			"The timestamps() method can be used to add two ‘TIMESTAMP’ columns to the table. The created_at and updated_at columns can be used to indicate when a row was created, and updated. [...] The timestamps() method doesn’t accept any parameters." rees (2013): 229

			softDeletes()
			"Occasionally you will want to mark table row as deleted, without actually deleting the data contained within. This is useful if you may wish to restore the data in the future. With the softDeletes() method you can place an indicator column on the row to show that the row has been deleted. The column that is created will be called deleted_at and will be of type ‘TIMESTAMP’. Once again, Laravel’s Eloquent ORM will be able to update this column, without deleting the row when you use the delete method on an ORM instance. [...] The softDeletes() method does not accept any parameters." rees (2013): 229-230

		Column modifiers
		 "Column modifiers can be used to add extra constraints or properties to the columns that we create with the create() method." rees (2013): 230

		 "[...] the column modifiers can be chained to an existing column definition. Alternatively, the column modifiers can be used in isolation by providing a column name as a parameter." rees (2013): 231

			unique()
			"By chaining the unique() method on to our column creation method, we have told the database that duplicate values will not be allowed for this column. Our primary key should be used to identify individual rows, so we don’t want to have duplicate values [...]" rees (2013): 230

			primary()
			"We can mark any column as a primary key using the primary() method. The only parameter to this method a string representing the name of the column to mark as the key. [...] both the primary() key, and the unique() methods are able to act on their own, or fluently chained to an existing value." rees (2013): 231

				Multiple composite keys
				"If you aren’t satisfied with a single primary key for your table, you can use multiple composite keys by providing an array of column names to the primary() method [...] whereby any combination of the values contained in the columns will be a unique reference to an individual role." rees (2013): 232

			index()
			"We can speed up our queries by marking columns that are used to lookup information as indexes. We can use the index() method to mark a column as an index. [...] We can also pass an array of column names to the index() method to mark multiple columns as indexes." dayñe (2013): 232-233

			nullable()
			"Sometimes we want to set a constraint on a column to state whether or not it can contain a null value. We can set a column to nullable using the nullable() method. [...] If we don’t want the column to allow a null value, we can pass boolean false as the first parameter to the nullable() chained method" rees (2013): 234

			default()
			"If we wish for our columns to contain a default value when a new row is created, we can provide the default value by chaining the default() method onto the new column definition. [...] The first and only parameter to the default() method is the intended default value for the column. [...] If we don’t provide a value for the ‘name’ column when creating a new row, then it will default to ‘John Doe’." rees (2013): 235

			unsigned()
			"[...] we can use the unsigned() chained method on an integer column to specify that it may not contain negative numbers." rees (2013): 235

		Updating tables

			Schema::rename()
			"First of all, we can change the name of a table that we have already created quite easily using the Schema::rename() method. [...] The first parameter of the rename() method is the name of the table that we wish to change. The second parameter to the method, is the new name for the table." rees (2013): 236-237

			Schema::table()
			"If we want to alter the columns of an existing table, we need to use the Schema::table() method. [...] The table() method is almost identical to the create() method we used earlier to create a table. The only difference is that it acts upon an existing table that we specify within the first parameter to the method. Once again, the second parameter contains a Closure with a parameter of a table builder instance." rees (2013): 237

			dropColumn()
			"If we decide that we no longer wish to have a column on our table, we can use the dropColumn() method to remove it. [...] The dropColumn() method will accept a string parameter, which is the name of the column that we wish to remove. [...] If we wish to remove more than one column at once, we can either provide an array of column names as the first parameter to the dropColumn() method [...] or we can simply provide multiple string parameters for column names." rees (2013): 238-239

			renameColumn()
			"The renameColumn() method is used to change the name of a column. The first parameter to the method is the name of the column that we wish to rename, and the second parameter is the new name for the column." rees (2013): 240

			dropPrimary()
			"Using the dropPrimary() method, we supply the name of a column as a parameter. This column will have its primary key attribute removed. [...] To remove a number of composite keys from a table, we can instead supply an array of column names as the first parameter of the dropPrimary() method." rees (2013): 240

			dropUnique()
			"We can remove the unique attribute for a column by using the dropUnique() method. This method accepts a single parameter, which consists of the table name, column name, and ‘unique’ separated by underscores. [...] we can pass an array of column names in same format to the dropUnique() method if we wish." rees (2013): 241

			dropIndex()
			"we can drop an index attribute from a table column by using... wait for it... okay you guessed it. We can use the dropIndex() method. Simply provide the column name in the same format as we used with the dropUnique() method, that’s table name, column name, and ‘index’." rees (2013): 242

		Dropping tables

			Schema::drop()
			"[...] we can drop a table using the Schema::drop() method [...] To drop a table we simply pass the name of the table as the first parameter of the Schema::drop() method." rees (2013): 242-243

			Schema::dropIfExists()
			"If we try to drop a table that doesn’t exist, then we will get an error. We can avoid this by instead using the dropIfExists() method. [...] the dropIfExists() method accepts a single parameter, the name of the table to drop." rees (2013): 243

		Schema tricks

			Schema::connection()
			"We can use the Schema::connection() method to perform our schema changes on an alternative database or connection. [...] The connection() method can be placed before any of the Schema class methods to form a chain. The first parameter for the method, is the name of the database connection which subsequent methods will act upon. The connection() method can be very useful if you need to write an application that uses multiple databases." rees (2013): 243-244

			Schema::hasTable()
			"We can use the hasTable() method to check for the existance of a table. The first parameter to the method is the name of the table that we wish to check." rees (2013): 244

			Schema::hasColumn()
			"We can use the Schema::hasColumn() method to check if a table has a column. The first parameter to the method is the table, and the second parameter is the name of the column that we want to look for." rees (2013): 245

			Change storage engine
			"[...] you might want to change the storage engine used by the table. [...] Simply change the value of the engine attribute on the table blueprint to the name of the storage engine that you wish to use. Here are some of the available storange engines for the mySQL database:
				MyISAM
				InnoDB
				IBMDM2I
				MERGE
				MEMORY
				EXAMPLE
				FEDERATED
				ARCHIVE
				CSV
				BLACKHOLE" rees (2013): 245

			after()
			"On mySQL databases, you are able to reorder the columns of a table by using the after() method. [...] Simply chain the after() method onto the column that you wish to reposition. The only parameter to the method is the name of the column that you wish for the new column to be placed after." rees (2013): 245-246

Migrations
 "Migrations are a number of PHP scripts that are used to change the structure or content of your database. Migrations are time stamped, so that they are always executed in the correct order. Laravel keeps a record of which migrations have already been executed within another table on your default database connection. This way, it will only ever execute any additional migrations that have been added. Using migrations, you and your team will always have the same database structure, in a consistant, stable state." rees (2013): 247-248

 	Creating migrations
 	 "To create a migration we need to use the Artisan command line interface. [...] We call the Artisan migrate:make command, and provide a name for our new migration. Laravel has new generated a new migration template within the app/database/migrations directory. The template will be located in a file named after the parameter that you supplied to the migrate:make command, with an attached timestamp." rees (2013): 248

 		Artisan command
 		"Now it’s important that you always use the Artisan command to generate migrations, you don’t want to risk breaking the timestamps and thus the history of your database structure." rees (2013): 249

 			tinker
 			"It’s an artisan command that comes with Laravel and allows us to work directly on Laravel code base through terminal. If we issue this command: php artisan tinker, it just opens up a nice interface on the terminal to work ceaselessly." sinha(2017): 54

	 	--create & --table
	 	"Using the --create and --table switches on the migrate:make command we can automatically create a stub for the creation of a new table. We simply run...
	 		php artisan migrate:make create_users --create --table=users" rees (2013): 251

	 	--path
	 	"We can use the --path switch to define a new location for our migration class. [...] However, when running your migrations, Artisan won’t look in this new location by default, so be sure to let it know where to find you migrations" rees (2013): 252

	 	up() & down()
	 	"[...] let us go to our 'database/migrations/' folder; we find that two PHP files have already been stored there. These migration files are ‘users’ and ‘password resets’. Laravel comes with them [...] there are only two functions: ‘up’ and ‘down’. The instructions written inside are fairly simple to understand. It tells us about creating columns in ‘users’ table. It mentions the characteristics of the columns: whether it’ll be ‘string’, or ‘text’, or have any extra feature of uniqueness. The method ‘up’ means you generate or update the tables. The method ‘down’ has a significant meaning. It means you can roll back your migrations any time, and generate it again." sinha (2017): 49-50

	 		Bidirectionality
	 		"Within the migration class we have two public methods, up() and down() [...] Whatever you do in the up() method, you must undo within the down() method. You see, migrations are bi-directional. We can run a migration to update the structure or content of our database, but we can also undo that migration to revert it to its orignal state." rees (2013): 249

	Running migrations

		Migration table
		"Now you can call the migrations table whatever you like. The configuration for the table name is located within app/config/database.php [...] Simply change the migrations index to the name of the table which you wish to use to track your migration status. A sensible default has been provided. We can install our migrations table by running another Artisan command. [php artisan migrate:install] [...] Laravel will automatically create the table for us if it doesn’t exist when your migrations are executed. It will install the migrations system for you." rees (2013): 252-253

		PHP file generation
	 	"Remember, whenever you run a migration, a PHP file is generated inside 'database/migrations' folder and it looks like this. Now, it’s our responsibility to add columns into it and again issue the migration command." sinha (2017): 51

	 	Non-standard migrations
	 	"We just use the --path switch again to specify the location where our migrations are stored relative to the application root." rees (2013): 257
	
	Rolling back
	"When we use the rollback command, Laravel rolls back only the migrations that were ran the last time we used migrate . It’s as if the last time that we ran migrate never happened. If we want to roll back all migrations, we can use the reset command. [...] the reset command will not remove our migrations table." rees (2013): 258

	Migration tricks

		--database
		"We can perform our migrations on another connection by supplying the --database switch to any of the migration commands [...]" rees (2013): 258

		--pretend
		"We can execute our migrations without altering the database, and we can see the intended SQL queries that are the result of our migrations. This way we can check to see what the next migration will do, without risking any damage to our database. This is really useful for debugging. To see the intended SQL result of a migration command, just add the --pretend switch." rees (2013): 258

Eloquent ORM
 "Object-oriented application design has taught us that we need to identify the objects within our application. [...] Normally we will refer to these application objects as ‘Models’, since they represent part of our applications business model." rees (2013): 260

 	Eloquent conventions
 	"Eloquent has some conventions, which, if followed, will make your life easier. This approach is known as convention over configuration, which means, if you follow these conventions, you will have to do very little configuration for things to "just work"." bean (2015): 47

 		Naming
 		"An Eloquent model is contained in a single class and is the "studly-cased", singular version of your database table's name. Studly-case is similar to camel-casing, but the first letter is uppercase as well. [...] There is no set place in the filesystem to place your Eloquent models; you are free to organize them as you see fit. You can use an Artisan command to create a model stub (a simple class with the basic structure of an Eloquent model). Artisan places new model classes in the app directory. You are free to move your model classes and store them in whatever directory you wish, just be sure to update the namespace declaration at the top of the file to reflect its new location." bean (2015): 47-48

	save()
	"The save() method would handle the SQL side of things for us. [...] This functionality is provided by object relational mappers, or simply‘ORM’s. ORMs can be used to allow us to map our application objects to database tables, and individual instances of these objects as rows. You can think of the class attributes of these objects as the individual columns for the table. The ORM will take care of object retrieval and persistance for us, we won’t have to write a single line of SQL." rees (2013): 262

	Creating new models

		Eloquent models
		"Eloquent is clever, by default it will look for the plural form of the model name as the table to use to store instances of our objects. [...] Eloquent models have a basic requirements. A model must have an auto incremental column named id . This is a unique primary key that can be used to identify a single row within the table. You can add this column to the table structure easily by using the increments() method." rees (2013): 263-264

			Eloquent vs other ORM
			"Many other ORMs will demand that you build an XML map of the database schema, or create annotations for each of the database columns of the table representing the object. We don’t need to do this because Eloquent makes some sensible assumptions." rees (2013): 264

				No-plural form of your model
				"If you don’t want your database table name to be the plural form of your model then you will need to let Eloquent know about it. Just add the $table public attribute to your model and set its value to the string name of your table. Eloquent will then use the provided table name for all future queries relating to this model." rees (2013): 270

				Namespaces
				"If you chose to namespace your models you will need to use the $table attribute to provide simple table names. This is because a model with the namespace and class combination of MyApp\Models\Game will result in an expected table name of my_app_models_games to avoid collisions with packages within other namespaces which also use the database. You will also notice that Eloquent is very clever, and will expand a camel cased namespace or model name into its snake cased variant." rees (2013): 270

			timestamps() by default	
			"When Eloquent creates our new model, it attempts to populate the updated_at and created_at columns of our table with the current time. This is because it expects us to have added the ->timestamps() method when building our table schema. It’s a sensible default, since it never hurts to have a record of creation/update times. However, if you are using an existing database table, or simply don’t wish to have the timestamp columns present within your database table, you may want to disable this functionality. To disable automatic timestamp updates with Eloquent models, just add a new public attribute to your model." rees (2013): 265

				$timestamps disable
				"The public attribute $timestamps is inherited from the Eloquent base class. It is a boolean value that can be used to enable or disable the automatic timestamp functionality." rees (2013): 265

				$timestamps enable
				"First we need to alter our database schema. It’s a bad idea to manually modify our database schema, or to update existing migrations. This is because our database state might become ‘out-of-sync’ with our teammates." rees (2013): 266

			id Column
			"[...] we didn’t have to specify an id value for our object. The id column is automatically incremented, so the database layer will handle the numbering of our rows for us. It’s generally a bad idea to modify the id column of an Eloquent model." rees (2013): 266

	Reading existing models

		Static find() method
		"The static find() method is inherited from the Eloquent parent class, and does not need to be created within your model." rees (2013): 271

	Updating existing models

		save() method
		"Just because we have save() d our model instance, it doesn’t have to mean we can’t modify it. We can alter its values directly and call the save() method once more to update the existing row. You see, the first time save() is used on a new object, it will create a new row and assign an auto incremental id column value. Future calls to the save() method will persist only the changes to columns for the existing row in our database. [...] The last saved state of the object will be present within the database." rees (2013): 271-272

	Deleting existing models

		delete() method
		"Deleting Eloquent models is a simple process. First we need to get our hands on the instance of the model that we wish to delete. [...] we can use the delete() method to remove the row represented by our model from the database." rees (2013): 274

		destroy() method
		"We can also delete a single instance, or multiple instances of our models from the database using their id column values and the destroy() static method. [...] To destroy multiple records, you can either pass a number of id value as parameters to the destroy() method [...] or an array of id ’s [...]" rees (2013): 275

Eloquent queries
	
	SQL functionality
	"With SQL, we can use a number of complex comparisons and set arithmatic to retrieve only the results that we require. Replicating all of this functionality with Eloquent would be a tremendous task, but fortunately, Eloquent has alternate methods for the most useful of queries. For all the bits that are missing we can use raw queries to provide SQL statements that will return Eloquent ORM result instances." rees (2013): 277

	Eloquent to string
	 "Objects in PHP can optionally include a __toString() method. [...] This method can be used to control how the object should be represented as a string. [...] Thanks to this method, our Eloquent models can also be expressed as a string. You see, the Eloquent base class that we extend with our own models contains a __toString() method. This method will return a JSON string that will represent the values of our Eloquent model." rees (2013): 280-281

		RESTful API
		"This is really useful when creating RESTful API’s that serve JSON data. It’s also a great way of expressing the output of our queries [...]" rees (2013): 282

		all() method
		"Some Eloquent methods will return a number of model instances as a result, instead of the single model instance [...] We use the all() method of our [...] model to retrieve an array of Eloquent model instances that represent the rows of our [...] table." rees (2013): 282

		Collections
		"[...] Laravel 4 doesn’t return an array from such methods, instead, it returns a Collection. [...] The Collection object implements an interface which allows for the object to be iterable. It can be looped through using the same functionality as standard PHP arrays. [...] the result of any methods that return multiple model instances is represented by an instance of Illuminate\Database\Eloquent\Collection. [...] this object holds an internal array of our model instances called items ." rees (2013): 282-283

			_toString()
			"[...] the Collection object also includes a __toString() method. This method functions in a similar manner to the one on our model instances, but instead creates a JSON string that will represent our model instances as a multi dimensional array."

	Query structure
	 "Eloquent queries can be broken down into three parts.
		The model
		Query Constraints
		Fetch methods." rees (2013): 285-286

		"Be sure to remember that the query builder required a trigger method at the end of the join to return a result collection." rees (2013): 357

		Model
		"The model is the model instance that we wish to perform the query upon." rees (2013): 286

		Fetch methods
		 "These are the methods that are used to perform the query, and return the result." rees (2013): 286

			JSON expression
			"Fetch methods can be used to return either a single model instance, or a Collection of model instances. However, as we discovered earlier, both can be expressed in JSON format as the response of a routed Closure or controller action." rees (2013): 287

			find()
			"The find() method can be used to retrieve a single Eloquent model instance by the id column of its row. If the first parameter of the method is an integer, then only a single instance will be returned. [...] If we instead provide an array of id values, we receive a Collection of model instances." rees (2013): 287-288

			all()
			"The all() method can be used to return a collection of model instances that represent all rows contained within the table." rees (2013): 288

			first()
			"In circumstances where a collection of model instances will normally be returned, the first() fetch method can be used to retrieve the first model instance stored within. It’s very useful if you would rather that a query return a single instance, rather than a collection of model instances. Without a constraint, first() will simply return the first row in the database table." rees (2013): 290

			update()
			"Using the update() method we can update the values of the table rows that are the result of the Eloquent query. Simply pass a key-value array as the first parameter to the update() method to change the column values for each row. The array key represents the name of the column to change, and the value represents the new intended value for the column. The update() method is special, and cannot be used without a constraint [...] The update() method doesn’t retrieve model instances [...]" rees (2013): 291

			delete()
			"[...] the delete() method will not return any instances. Instead, it will remove the rows that are the result of the query from the database table." rees (2013): 292

			truncate()
			"If you intend to delete all table rows for a specific model, you might find the truncate() method to be more descriptive." rees (2013): 294

			get()
			"Get is the most important of our fetch methods. It is used to retrieve the result of the query. [...] The get() method has an optional parameter. You can pass an array of column names to it and the result objects will only contain values for those columns."rees (2013): 294-295

			pluck()
			"The pluck() method can be used to retrieve a value for a single column. [...] The first and only parameter, is the name of the column that we wish to retrieve the value for. If the query matches multiple results, then only the value of the first result will be returned." rees (2013): 296

			lists()
			"While the pluck() method will retrieve only one value for a specific column, the lists() method will retrieve an array of values for the specified column across all result instances. [...] the lists() method accepts one single parameter. The name of column that we wish to retrieve all values for." rees (2013): 297

			toSQL()
			"You can use the toSql() method anywhere where you would normally use a fetch method, typically the end of a query chain, and it will return the SQL that represents the query as a string." rees (2013): 297

				Prepared statements
				"Laravel’s query builder uses prepared statements. This means that the question marks are placeholders that will be replaced with your actual values or ‘bindings’. The benefit is that your bindings will be escaped before replaced into the string, to avoid an SQL injection attempt." rees (2013): 298

		Query constraints
		 "Query constraints are rules that are used to match a subset of our table rows. This way we can return only the rows that we are interested in. The most familiar constraint used with SQL is the WHERE clause." rees (2013): 286

		 "In mathematics, set based arithmatic allows us to capture a subset of a much larger set of values. This is essentially what we are trying to accomplish using query constraints [...]" rees (2013): 298

			Optional
			"All of our queries act upon one of our Eloquent models. The constraint methods are entirely optional [...] Next we have a fetch method. [...] The first method of a query chain is always called statically, with two colons :: . Eloquent queries can consist of no constrains, a single constraint, or many constraints. [...] Constraints are entirely optional, but all queries must begin with a model, and end with a fetch method." rees (2013): 286

			or*() prefix
			"most of the constraints within this chapter will have an alternative version prefixed with or that will allow an alternate constraint to match." rees (2013): 302

			where()
			"If you have used SQL in the past, then you will likely have come across the WHERE clause for retrieving table rows by matching the value of their columns." rees (2013): 298

				Parameters
				"The where() method will accept three parameters. The first parameter is name of the column that we wish to perform the comparison on. [...] The second parameter is the operator to use for the comparison.[...] We could [...] [use] any of the other common comparison operators supported by the SQL, such as < , > , => , =< , etc. [...] The third parameter is value that we will compare with. [...] Once again, the where() method is only a query constraint. We will use the get() method to retrieve a Collection of results." rees (2013): 299

				LIKE
				"The LIKE SQL operator can be used to compare parts of a string by using a percentage % symbol as a wildcard." rees (2013): 300

				Multiple where()
				"We can chain multiple where() methods together to retrieve rows based on a number of different criteria. [...] The and is important. Both constraints must match for a row to exist within the result set." rees (2013): 301

					"You can chain together as many where() and orWhere() methods as you need to filter your table rows down to the required result set." rees (2013): 303

				whereRaw()
				"The whereRaw() method can be used to provide a string of SQL to perform a WHERE condition on the result set. [...] The whereRaw() method accepts a string of SQL as its first paramater. All question ? marks within the string are replaced by array elements from the second parameter to the method in sequential order. If you have ever bound properties to a prepared statement with SQL then this syntax will be familiar to you. The values provided will be escaped to avoid SQL injection attacks." rees (2013): 303-304

					Multiple whereRaw()
					"You can use the whereRaw() method in circumstances where you require complex SQL in addition to your where() type constraints. Just like the where() method, the whereRaw() method can be chained multiple times and with other constraint methods to limit your result set. Once again the orWhereRaw() method is included to allow for alternate conditions." rees (2013): 304

				whereBetween()
				"The whereBetween() method is used to check that the value of a column is between two provided values. [...] The first parameter to the whereBetween() method is the name of the column that we wish to compare. The second parameter is an array of two values, a starting value and a limit." rees (2013): 304-305

					Multiple whereBetween()
					"Just as with the other where() type methods, you can chain as many as you need to, and as always, we have an orWhereBetween() alternative method." rees (2013): 306

				whereNested()
				"The whereNested() method is a clean way of applying multiple where constraints to a query. Simply pass a Closure as the first parameter to the method, and give the Closure a placeholder parameter named whatever you like. [..] Within the Closure you may apply as many where() type constraints or orWhere() type constraints to the $query object, which will then become part of your main query." rees (2013): 306

					No or*()
					"Note that there is no orWhereNested() alternative to this method, but here’s the secret... you can also pass a Closure to orWhere()." rees (2013): 307

				whereIn()
				"The whereIn() method can be used to check that a column value exists within a set of values. It’s really useful when you already have an array of possible values to hand. [...] The first parameter to the whereIn() method is the column that we wish to perform the comparison on. The second value is the array of values to search within. [...] The whereIn() method also has the usual method alternative in the form of orWhereIn() and can be chained multiple times." rees (2013): 308-309

				whereNotIn()
				"The whereNotIn() method is the direct opposite to the whereIn() method. This time you provide a list of values, and the column value must not exist within the set. [...] we pass the comparison column as the first parameter, and our array of values as the second parameter." rees (2013): 309-310

				whereNull()
				"The whereNull() constraint can be used when you need to retrieve rows that have a column value of NULL. [...] The single parameter for the whereNull() method is name of the column that you wish to contain a null value. [...] The orWhereNull() method is also available." rees (2013): 311

				whereNotNull()
				"The whereNotNull() method is the opposite of the whereNull() method, so this time we should be able to see some results. It will return rows that have a column value that isn’t equal to NULL. [...] The first, and only parameter to the method is the column name. [...] the orWhereNotNull() method is available to perform an or type query." rees (2013): 311-312

				orderBy()
				"The orderBy() method can be used to order the results returned by your query by the value of a specific column. [...] The first parameter to the orderBy() method is the name of the column that we wish to order by. By default, the ordering will be in ascending order." rees (2013): 312-313

					"We add a second parameter to the orderBy() method with a value of desc . This tells Laravel that we wish to retrieve our results in descending order. [...] You can use the orderBy() clause with any combination of the constraints [...] You can also use additional orderBy() methods to provide additional ordering, in the order that the methods are provided." rees (2013): 314

				take()
				"The take() method can be used to limit the resultset. [...] The first parameter to the take() method is the amount of rows that you wish to limit by. [...] Take can be used in combination with any of the other query constraints." rees (2013): 314-315

				skip()
				"When using the take() method, the skip() method can be used to provide an offset for the query result set. [...] The skip() method accepts a single parameter to provide an offset." rees (2013): 315-316

				Magic where queries
				"You can simply append the name of the column that you wish to query on to the where() method. First you must capitalize the first letter of the field that you wish to compare. [...] If our field name is snake cased, for example, shoe_size , then we must uppercase the first letter of each word to whereShoeSize(). The only parameter to the magical where() method is the expected value of the column [...]" rees (2013): 318

		Query scopes

			scope*()
			"It’s a special method with a specific function, it will help us re-use common queries.All scope methods begin with the word scope, and then an identifier. The method will accept a single parameter, a $query object. This object can be used to construct queries [...]" rees(2013): 319-320

Eloquent collections
 "Eloquent collections are an extension of Laravel’s Collection class with some handy methods for dealing with query results. The Collection class itself, is merely a wrapper for an array of objects, but has a bunch of other interesting methods to help you pluck items out of the array. [...] you can still iterate through a collection of results with the variety of loops that PHP offers because it inherits some properties of an array, but because the collection is a class, and not native type, there are also methods available on the object." rees (2013): 321

	Collections methods
	 "Some of the methods are related to inserting, and retrieving elements by their key. However, in the case of Eloquent results, the keys do not match the primary key of the tables that the model instances represent, and so these methods will be very useful to us." rees (2013): 321

		all()
		"The all() method can be used to get hold of the internal array used by the Collection object." rees (2013): 322

		first()
		"The first() method of the collection can be used to retrieve the first element in the set. This will be the first element contained within the collections internal array." rees (2013): 323

		last()
		"The first() method was used to retrieve the first value contained within the collections internal array, this means that the last() method must retrieve the last item of the array." rees (2013): 325

		shift()
		"The shift() method is similar to the first() method. It will retrieve the first value within the collections internal array. However, unlike the first() method, the shift() method will also remove that value from the array. [...]Remember that the collection inherits many properties of an array, this allows the count() method to act upon it. [...] the instance has not only been returned from the method, but also removed from the array." rees (2013): 327-328

		pop()
		"[...] it’s also a method on the Eloquent model instances collection. It works in a similar way to the shift() method in that it will return the value from the end of the internal array, and remove it." rees (2013): 329

		each()
		"Instead of creating a foreach() loop to iterate over our results, we can instead pass a Closure to the each() method. [...] Our Closure accepts a parameter that will be a placeholder for the current object within the iteration. This closure is then passed to the each() method." rees (2013): 330-331

		map()
		"The map() function works in a similar way to the each() method. However it can be used to iterate and work with our collection elements, returning a new collection as a result. [...] First we ensure that the value of Collection::map() method is assigned to a variable. Then we iterate the collection in the same manner as the each() method, but this time we return each value that we wish to be present within the new collection." rees(2013): 331-332

		filter()
		"The filter() method can be used to reduce the number of elements contained within the resulting collection by using a Closure. If the result of the Closure is boolean true then the current element of the iteration will be given to the resulting collection. If the Closures iteration returns a false or nothing at all, then that element will not exist within the new collection." rees (2013): 332

		sort()
		"The sort() method can be used to sort the collection. It hands our Closure to the uasort() PHP method which uses integer values to represent a comparison between two values. Our closure receives two parameters, let’s call them A and B. Then we apply the rules of our sorting to provide an integer result from our closure. If A > B then we return 1. If A < B then we return -1. If A = B then we return 0. [...] This method is descructive. It alters the original collection." rees(2013): 334-335

		reverse()
		"The reverse() method can be used to reverse() the models contained within the internal array." rees (2013): 336

		merge()
		"The merge() method can be used to combine two collections. The only parameter to the method is the collection that should be merged." rees (2013): 337

		slice()
		"The slice() method is the equivelent of the PHP slice() function. It can be used to produce a subset of models using a collection offset. [...] The first parameter is the position that the new sub set is started. Here we are telling it to start slicing at the second element of the array. The second optional parameter is the length of the collection. [...] The slice() method does not wrap around the collection." rees(2013): 338-339

		isEmpty()
		"The isEmpty() method can be used to check whether or not the container has elements within it. [...] It accepts no value, and returns a boolean result." rees(2013): 339

		toArray()
		"The toArray() method can be used to return the internal array of the collection. Also, any elements within the array that that can be transformed into an array, for example objects, will be transformed during the process." rees(2013): 340

		toJson()
		"The toJson() method will tranform the collection into a JSON string that can be used to represent it’s contents. [...] we discovered how to return collections directly from a routed closure or controller action to serve a JSON response. The toString() method allowing the collection to be transformed to JSON makes a call to the toJson() method internally." rees(2013): 341

		count()
		"[...] count the number of model instances contained within the collection’s internal array." rees (2013): 342

	Best practice
	 "Some of the methods available to the collection are duplicates of those available on the query builder. For example, we can use the first() method when building eloquent queries to retrieve only a single model instance. We can also use the first() method of the collection to retrieve the first element contained within." rees (2013): 343

Eloquent relationships
	
	pivot table
	"Whenever you need a many_to_many relationship you will find a need for a pivot table. It’s the database table that links the two entities together by using two foreign keys to define the rows from the other tables." rees (2008): 351

			Format
			"Eloquent required a plural form of the model for its table name (unless we specify otherwise), [...] The default format for the pivot table is the singular form of the two related models separated by an _ underscore. The order of the instances should be alphabetical. [...] All foreign key columns follow a similar naming convention. The singular form of the related model appended with _id ." rees (2013): 352


	$this->hasMany() method 
	"This is one of the many relationship methods that are inherited from the Eloquent base class. The first parameter to the relationship method is the full name of the model to be related. If we decide to namespace our [...] model later, we will need to insert the full namespaced class as a parameter. [...] we can specify the alternative name of the column as an optional second parameter to this method." rees (2008): 354

	$this->belongsTo() method
	"The first parameter once again is the related model name, and once again we can provide an optional second parameter to use an alternative column name." rees (2008): 355

	$this->belongsToMany() method 
	" [...] informs Eloquent that it should look at a pivot table for related models. The first parameter is, once again, the name of the related model including namespace if present. This time we have a different set of optional parameters. [...] The second, optional parameter is the name of the pivot table to use for related objects. The third and fourth parameters are used to identify alternate naming schemes for the two foreign keys that are used to related our objects within the pivot table." rees (2008): 355
	
		belongs_to_many
		"When both the relationship and its inverse relationship are has_many then we will need to implement a new type of relationship. First of all, instead of saying has_many we will say belongs_to_many. This way we won’t confuse it with the other relationship. This new type of relationship forms a many_to_many relationship, and requires an additional table." rees (2008): 350

	Reationships method
	"Inside our Eloquent model definition we have a relationships method. [...] The name of the public method doesn’t require a strict format. It will serve as a nickname that we can use to refer to the relationship. [...] The first parameter to the relationship method is the full name of the model to be related. [...] we will need to insert the full namespaced class as a parameter. [...] then we can specify the alternative name of the column as an optional second parameter to this method." rees (2013): 354

		associate()
		"The associate method is a helper method available on relationships to create the relation between two objects. It will update the foreign key for the relationship accordingly. [...] Don’t forget to save() the model that you intend to relate, before passing it to the associate() method. The reason for this is that the model instance will require a primary key to create the relation, and the model will only receive a primary key value when it has been saved." rees (2013): 357-358

			many to many relationship
			"Relating objects that form many to many relationships is handled in a slightly different way. [...] instead of using the associate() method on our relationship, we instead use the save() method, passing the object to relate as the first parameter. The effect is the same, only this time the pivot table will be updated to define the relationship. If you would like to associate a model by its primary key directly, you can use the attach() method which accepts the primary key as the first parameter." rees (2013): 358-359

		detach()
		"To remove a relationship between two objects you can use the detach() method on the relationship. Just pass either a primary key, or an object as the first parameter. [...] We can remove all associations for an object that has a many to many relationship by calling the detach() method with no parameter on the relationship method." rees (2013): 359-360

